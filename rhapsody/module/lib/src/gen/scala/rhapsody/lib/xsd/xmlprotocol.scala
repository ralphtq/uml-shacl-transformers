// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package rhapsody.lib.xsd

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[rhapsody.lib.xsd.Foo](node)
val document = scalaxb.toXML[rhapsody.lib.xsd.Foo](obj, "foo", rhapsody.lib.xsd.defaultScope)
**/
object `package` extends XsdXMLProtocol { }

trait XsdXMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val Rhapsodylibxsd_XsdM_hReferencedDiagramFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_hReferencedDiagram] = new DefaultRhapsodylibxsd_XsdM_hReferencedDiagramFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_lastModifiedTimeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_lastModifiedTime] = new DefaultRhapsodylibxsd_Xsd_lastModifiedTimeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_typeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_type] = new DefaultRhapsodylibxsd_XsdM_typeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_styleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_style] = new DefaultRhapsodylibxsd_XsdM_styleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_positionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_position] = new DefaultRhapsodylibxsd_XsdM_positionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pRootFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pRoot] = new DefaultRhapsodylibxsd_XsdM_pRootFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pParentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pParent] = new DefaultRhapsodylibxsd_XsdM_pParentFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pModelObjectFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pModelObject] = new DefaultRhapsodylibxsd_XsdM_pModelObjectFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_name] = new DefaultRhapsodylibxsd_XsdM_nameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nOrientationCtrlPtFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nOrientationCtrlPt] = new DefaultRhapsodylibxsd_XsdM_nOrientationCtrlPtFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nModifyDateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nModifyDate] = new DefaultRhapsodylibxsd_XsdM_nModifyDateFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nIdentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nIdent] = new DefaultRhapsodylibxsd_XsdM_nIdentFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nCreateDateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nCreateDate] = new DefaultRhapsodylibxsd_XsdM_nCreateDateFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_modifiedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_modified] = new DefaultRhapsodylibxsd_XsdM_modifiedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_fgColorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_fgColor] = new DefaultRhapsodylibxsd_XsdM_fgColorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_drawBehaviorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_drawBehavior] = new DefaultRhapsodylibxsd_XsdM_drawBehaviorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_currentRightBottomFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_currentRightBottom] = new DefaultRhapsodylibxsd_XsdM_currentRightBottomFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_currentLeftTopFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_currentLeftTop] = new DefaultRhapsodylibxsd_XsdM_currentLeftTopFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIColorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIColor] = new DefaultRhapsodylibxsd_XsdIColorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_displayOptionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_displayOption] = new DefaultRhapsodylibxsd_XsdM_displayOptionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_strFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_str] = new DefaultRhapsodylibxsd_XsdM_strFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGITextFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIText] = new DefaultRhapsodylibxsd_XsdCGITextFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGITextSequence1Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGITextSequence1] = new DefaultRhapsodylibxsd_XsdCGITextSequence1Format {}
  implicit lazy val Rhapsodylibxsd_Xsd_iTempdisplayTextFlagFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag] = new DefaultRhapsodylibxsd_Xsd_iTempdisplayTextFlagFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bIsBoxStyleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsBoxStyle] = new DefaultRhapsodylibxsd_XsdM_bIsBoxStyleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdItemsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdItems] = new DefaultRhapsodylibxsd_XsdItemsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIAnnotationFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIAnnotation] = new DefaultRhapsodylibxsd_XsdCGIAnnotationFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIGenericElementFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIGenericElement] = new DefaultRhapsodylibxsd_XsdCGIGenericElementFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGICompartmentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGICompartment] = new DefaultRhapsodylibxsd_XsdCGICompartmentFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_colorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_color] = new DefaultRhapsodylibxsd_XsdM_colorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bgFlagFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bgFlag] = new DefaultRhapsodylibxsd_XsdM_bgFlagFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bgColorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bgColor] = new DefaultRhapsodylibxsd_XsdM_bgColorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bScaleWithZoomFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bScaleWithZoom] = new DefaultRhapsodylibxsd_XsdM_bScaleWithZoomFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bIsPreferencesInitializedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized] = new DefaultRhapsodylibxsd_XsdM_bIsPreferencesInitializedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bImplicitSetRectPointsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints] = new DefaultRhapsodylibxsd_XsdM_bImplicitSetRectPointsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bFreezeCompartmentContentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent] = new DefaultRhapsodylibxsd_XsdM_bFreezeCompartmentContentFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_arrowStyleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_arrowStyle] = new DefaultRhapsodylibxsd_XsdM_arrowStyleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_accessFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_access] = new DefaultRhapsodylibxsd_XsdM_accessFormat {}
  implicit lazy val Rhapsodylibxsd_XsdElementListFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdElementList] = new DefaultRhapsodylibxsd_XsdElementListFormat {}
  implicit lazy val Rhapsodylibxsd_XsdICommentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIComment] = new DefaultRhapsodylibxsd_XsdICommentFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_defaultSubsystemFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_defaultSubsystem] = new DefaultRhapsodylibxsd_Xsd_defaultSubsystemFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_propertiesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_properties] = new DefaultRhapsodylibxsd_Xsd_propertiesFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_ValueFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Value] = new DefaultRhapsodylibxsd_Xsd_ValueFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_rmmServerIDFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_rmmServerID] = new DefaultRhapsodylibxsd_Xsd_rmmServerIDFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_TypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Type] = new DefaultRhapsodylibxsd_Xsd_TypeFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_NameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Name] = new DefaultRhapsodylibxsd_Xsd_NameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdSubjectsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdSubjects] = new DefaultRhapsodylibxsd_XsdSubjectsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdPropertiesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdProperties] = new DefaultRhapsodylibxsd_XsdPropertiesFormat {}
  implicit lazy val Rhapsodylibxsd_XsdMetaclassesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdMetaclasses] = new DefaultRhapsodylibxsd_XsdMetaclassesFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIPropertySubjectFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIPropertySubject] = new DefaultRhapsodylibxsd_XsdIPropertySubjectFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIPropertyMetaclassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIPropertyMetaclass] = new DefaultRhapsodylibxsd_XsdIPropertyMetaclassFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIPropertyContainerFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIPropertyContainer] = new DefaultRhapsodylibxsd_XsdIPropertyContainerFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_ExtraTypeInfoFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_ExtraTypeInfo] = new DefaultRhapsodylibxsd_Xsd_ExtraTypeInfoFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIPropertyFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIProperty] = new DefaultRhapsodylibxsd_XsdIPropertyFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIMSCFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIMSC] = new DefaultRhapsodylibxsd_XsdIMSCFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIsConfigurationFileHyperLinkFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink] = new DefaultRhapsodylibxsd_XsdIsConfigurationFileHyperLinkFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_transformFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_transform] = new DefaultRhapsodylibxsd_XsdM_transformFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_linkTargetFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkTarget] = new DefaultRhapsodylibxsd_Xsd_linkTargetFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_linkDispNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkDispName] = new DefaultRhapsodylibxsd_Xsd_linkDispNameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_SubTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_SubType] = new DefaultRhapsodylibxsd_XsdM_SubTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIPortConnectorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIPortConnector] = new DefaultRhapsodylibxsd_XsdCGIPortConnectorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIDiagramFrameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIDiagramFrame] = new DefaultRhapsodylibxsd_XsdCGIDiagramFrameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIMHyperLinkFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIMHyperLink] = new DefaultRhapsodylibxsd_XsdIMHyperLinkFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_textRTFFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_textRTF] = new DefaultRhapsodylibxsd_Xsd_textRTFFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_textFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_text] = new DefaultRhapsodylibxsd_Xsd_textFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_descriptionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_description] = new DefaultRhapsodylibxsd_Xsd_descriptionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIDescriptionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIDescription] = new DefaultRhapsodylibxsd_XsdIDescriptionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdAggregatesListFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdAggregatesList] = new DefaultRhapsodylibxsd_XsdAggregatesListFormat {}
  implicit lazy val Rhapsodylibxsd_XsdSizeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdSize] = new DefaultRhapsodylibxsd_XsdSizeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdConveyedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdConveyed] = new DefaultRhapsodylibxsd_XsdConveyedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdAssociationsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdAssociations] = new DefaultRhapsodylibxsd_XsdAssociationsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIAssociationEndFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIAssociationEnd] = new DefaultRhapsodylibxsd_XsdIAssociationEndFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIDiagramFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIDiagram] = new DefaultRhapsodylibxsd_XsdIDiagramFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIAttributeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIAttribute] = new DefaultRhapsodylibxsd_XsdIAttributeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIClassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIClass] = new DefaultRhapsodylibxsd_XsdIClassFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIClassifierHandleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIClassifierHandle] = new DefaultRhapsodylibxsd_XsdIClassifierHandleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIDependencyFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIDependency] = new DefaultRhapsodylibxsd_XsdIDependencyFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_defNumberFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_defNumber] = new DefaultRhapsodylibxsd_Xsd_defNumberFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_versionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_version] = new DefaultRhapsodylibxsd_Xsd_versionFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_baseVersionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_baseVersion] = new DefaultRhapsodylibxsd_Xsd_baseVersionFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_diagramFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_diagram] = new DefaultRhapsodylibxsd_Xsd_diagramFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIStateChartFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIStateChart] = new DefaultRhapsodylibxsd_XsdIStateChartFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIGeneralizationFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIGeneralization] = new DefaultRhapsodylibxsd_XsdIGeneralizationFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIHandleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIHandle] = new DefaultRhapsodylibxsd_XsdIHandleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIHandleSequence1Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIHandleSequence1] = new DefaultRhapsodylibxsd_XsdIHandleSequence1Format {}
  implicit lazy val Rhapsodylibxsd_XsdIInformationFlowFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIInformationFlow] = new DefaultRhapsodylibxsd_XsdIInformationFlowFormat {}
  implicit lazy val Rhapsodylibxsd_XsdILiteralSpecificationFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdILiteralSpecification] = new DefaultRhapsodylibxsd_XsdILiteralSpecificationFormat {}
  implicit lazy val Rhapsodylibxsd_XsdINObjectHandleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdINObjectHandle] = new DefaultRhapsodylibxsd_XsdINObjectHandleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdINObjectHandleSequence2Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdINObjectHandleSequence2] = new DefaultRhapsodylibxsd_XsdINObjectHandleSequence2Format {}
  implicit lazy val Rhapsodylibxsd_XsdINObjectHandleSequence1Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdINObjectHandleSequence1] = new DefaultRhapsodylibxsd_XsdINObjectHandleSequence1Format {}
  implicit lazy val Rhapsodylibxsd_XsdIPartFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIPart] = new DefaultRhapsodylibxsd_XsdIPartFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIPortFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIPort] = new DefaultRhapsodylibxsd_XsdIPortFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIRPYRawContainerFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIRPYRawContainer] = new DefaultRhapsodylibxsd_XsdIRPYRawContainerFormat {}
  implicit lazy val Rhapsodylibxsd_XsdISysMLPortFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdISysMLPort] = new DefaultRhapsodylibxsd_XsdISysMLPortFormat {}
  implicit lazy val Rhapsodylibxsd_XsdITagFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdITag] = new DefaultRhapsodylibxsd_XsdITagFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIStateChartDiagramFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIStateChartDiagram] = new DefaultRhapsodylibxsd_XsdIStateChartDiagramFormat {}
  implicit lazy val Rhapsodylibxsd_XsdMagicNumberFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdMagicNumber] = new DefaultRhapsodylibxsd_XsdMagicNumberFormat {}
  implicit lazy val Rhapsodylibxsd_XsdOslcLinksFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdOslcLinks] = new DefaultRhapsodylibxsd_XsdOslcLinksFormat {}
  implicit lazy val Rhapsodylibxsd_XsdOwnedDependenciesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdOwnedDependencies] = new DefaultRhapsodylibxsd_XsdOwnedDependenciesFormat {}
  implicit lazy val Rhapsodylibxsd_XsdOperationsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdOperations] = new DefaultRhapsodylibxsd_XsdOperationsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_AdditionalLabelFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_AdditionalLabel] = new DefaultRhapsodylibxsd_XsdM_AdditionalLabelFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nNameFormatFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nNameFormat] = new DefaultRhapsodylibxsd_XsdM_nNameFormatFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nIsNameFormatFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nIsNameFormat] = new DefaultRhapsodylibxsd_XsdM_nIsNameFormatFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bFramesetModifiedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bFramesetModified] = new DefaultRhapsodylibxsd_XsdM_bFramesetModifiedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdFramesetFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdFrameset] = new DefaultRhapsodylibxsd_XsdFramesetFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_anglePoint1Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_anglePoint1] = new DefaultRhapsodylibxsd_XsdM_anglePoint1Format {}
  implicit lazy val Rhapsodylibxsd_XsdM_anglePoint2Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_anglePoint2] = new DefaultRhapsodylibxsd_XsdM_anglePoint2Format {}
  implicit lazy val Rhapsodylibxsd_XsdM_ShowNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_ShowName] = new DefaultRhapsodylibxsd_XsdM_ShowNameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_ShowStereotypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_ShowStereotype] = new DefaultRhapsodylibxsd_XsdM_ShowStereotypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_SourcePortFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_SourcePort] = new DefaultRhapsodylibxsd_XsdM_SourcePortFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_TargetPortFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_TargetPort] = new DefaultRhapsodylibxsd_XsdM_TargetPortFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_arrowFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_arrow] = new DefaultRhapsodylibxsd_XsdM_arrowFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_polygonFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_polygon] = new DefaultRhapsodylibxsd_XsdM_polygonFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIImageDataFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIImageData] = new DefaultRhapsodylibxsd_XsdCGIImageDataFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIObjectInstanceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIObjectInstance] = new DefaultRhapsodylibxsd_XsdCGIObjectInstanceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIClassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIClass] = new DefaultRhapsodylibxsd_XsdCGIClassFormat {}
  implicit lazy val Rhapsodylibxsd_XsdAttrsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdAttrs] = new DefaultRhapsodylibxsd_XsdAttrsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_conveyedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_conveyed] = new DefaultRhapsodylibxsd_XsdM_conveyedFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_itsTargetFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itsTarget] = new DefaultRhapsodylibxsd_Xsd_itsTargetFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowKeywordFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowKeyword] = new DefaultRhapsodylibxsd_XsdM_bShowKeywordFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_itsSourceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itsSource] = new DefaultRhapsodylibxsd_Xsd_itsSourceFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_staticReactionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_staticReaction] = new DefaultRhapsodylibxsd_Xsd_staticReactionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIStateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIState] = new DefaultRhapsodylibxsd_XsdCGIStateFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIStateChartFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIStateChart] = new DefaultRhapsodylibxsd_XsdCGIStateChartFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIClassChartFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIClassChart] = new DefaultRhapsodylibxsd_XsdCGIClassChartFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIImageFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIImage] = new DefaultRhapsodylibxsd_XsdCGIImageFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIInheritanceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIInheritance] = new DefaultRhapsodylibxsd_XsdCGIInheritanceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGITransFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGITrans] = new DefaultRhapsodylibxsd_XsdCGITransFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIInformationFlowFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIInformationFlow] = new DefaultRhapsodylibxsd_XsdCGIInformationFlowFormat {}
  implicit lazy val Rhapsodylibxsd_XsdITransitionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdITransition] = new DefaultRhapsodylibxsd_XsdITransitionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdILabelFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdILabel] = new DefaultRhapsodylibxsd_XsdILabelFormat {}
  implicit lazy val Rhapsodylibxsd_XsdRHAPSODYu45MODELFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL] = new DefaultRhapsodylibxsd_XsdRHAPSODYu45MODELFormat {}
  implicit lazy val Rhapsodylibxsd_XsdRhapsodyArchiveFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdRhapsodyArchive] = new DefaultRhapsodylibxsd_XsdRhapsodyArchiveFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIStateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIState] = new DefaultRhapsodylibxsd_XsdIStateFormat {}
  implicit lazy val Rhapsodylibxsd_XsdStereotypesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdStereotypes] = new DefaultRhapsodylibxsd_XsdStereotypesFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_baseFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_base] = new DefaultRhapsodylibxsd_Xsd_baseFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_classModifierFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_classModifier] = new DefaultRhapsodylibxsd_Xsd_classModifierFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_dependentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_dependent] = new DefaultRhapsodylibxsd_Xsd_dependentFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_dependsOnFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_dependsOn] = new DefaultRhapsodylibxsd_Xsd_dependsOnFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_directionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_direction] = new DefaultRhapsodylibxsd_Xsd_directionFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_displayNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_displayName] = new DefaultRhapsodylibxsd_Xsd_displayNameFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hclassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hclass] = new DefaultRhapsodylibxsd_Xsd_hclassFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hfilenameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hfilename] = new DefaultRhapsodylibxsd_Xsd_hfilenameFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hidFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hid] = new DefaultRhapsodylibxsd_Xsd_hidFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hm2ClassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hm2Class] = new DefaultRhapsodylibxsd_Xsd_hm2ClassFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hnameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hname] = new DefaultRhapsodylibxsd_Xsd_hnameFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_hsubsystemFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hsubsystem] = new DefaultRhapsodylibxsd_Xsd_hsubsystemFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_idFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_id] = new DefaultRhapsodylibxsd_Xsd_idFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_implicitClassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_implicitClass] = new DefaultRhapsodylibxsd_Xsd_implicitClassFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_inheritanceTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_inheritanceType] = new DefaultRhapsodylibxsd_Xsd_inheritanceTypeFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_inverseFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_inverse] = new DefaultRhapsodylibxsd_Xsd_inverseFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_isConstantFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isConstant] = new DefaultRhapsodylibxsd_Xsd_isConstantFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_isOrderedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isOrdered] = new DefaultRhapsodylibxsd_Xsd_isOrderedFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_isReferenceAttrFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isReferenceAttr] = new DefaultRhapsodylibxsd_Xsd_isReferenceAttrFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_isVirtualFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isVirtual] = new DefaultRhapsodylibxsd_Xsd_isVirtualFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_itsStateChartFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itsStateChart] = new DefaultRhapsodylibxsd_Xsd_itsStateChartFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_lastIDFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_lastID] = new DefaultRhapsodylibxsd_Xsd_lastIDFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_linkTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkType] = new DefaultRhapsodylibxsd_Xsd_linkTypeFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_modifiedTimeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_modifiedTime] = new DefaultRhapsodylibxsd_Xsd_modifiedTimeFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_modifiedTimeWeakFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_modifiedTimeWeak] = new DefaultRhapsodylibxsd_Xsd_modifiedTimeWeakFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_multiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_multiplicity] = new DefaultRhapsodylibxsd_Xsd_multiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_myStateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_myState] = new DefaultRhapsodylibxsd_Xsd_myStateFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_name2Format: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_name2] = new DefaultRhapsodylibxsd_Xsd_name2Format {}
  implicit lazy val Rhapsodylibxsd_Xsd_navigabilityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_navigability] = new DefaultRhapsodylibxsd_Xsd_navigabilityFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_otherClassFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_otherClass] = new DefaultRhapsodylibxsd_Xsd_otherClassFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_protectionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_protection] = new DefaultRhapsodylibxsd_Xsd_protectionFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_staticFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_static] = new DefaultRhapsodylibxsd_Xsd_staticFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_theMainDiagramFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_theMainDiagram] = new DefaultRhapsodylibxsd_Xsd_theMainDiagramFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_typeOfFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_typeOf] = new DefaultRhapsodylibxsd_Xsd_typeOfFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_value2Format: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_value2] = new DefaultRhapsodylibxsd_Xsd_value2Format {}
  implicit lazy val Rhapsodylibxsd_XsdDirectionu93Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdDirectionu93] = new DefaultRhapsodylibxsd_XsdDirectionu93Format {}
  implicit lazy val Rhapsodylibxsd_XsdEnd1u93Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdEnd1u93] = new DefaultRhapsodylibxsd_XsdEnd1u93Format {}
  implicit lazy val Rhapsodylibxsd_XsdEnd2u93Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdEnd2u93] = new DefaultRhapsodylibxsd_XsdEnd2u93Format {}
  implicit lazy val Rhapsodylibxsd_XsdFileNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdFileName] = new DefaultRhapsodylibxsd_XsdFileNameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdStrongCGTimeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdStrongCGTime] = new DefaultRhapsodylibxsd_XsdStrongCGTimeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdWeakCGTimeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdWeakCGTime] = new DefaultRhapsodylibxsd_XsdWeakCGTimeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_dataFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_data] = new DefaultRhapsodylibxsd_XsdM_dataFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_dataSizeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_dataSize] = new DefaultRhapsodylibxsd_XsdM_dataSizeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_directionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_direction] = new DefaultRhapsodylibxsd_XsdM_directionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_fileModifiedTimeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_fileModifiedTime] = new DefaultRhapsodylibxsd_XsdM_fileModifiedTimeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_flow_directionFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_flow_direction] = new DefaultRhapsodylibxsd_XsdM_flow_directionFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_keywordFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_keyword] = new DefaultRhapsodylibxsd_XsdM_keywordFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_line_styleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_line_style] = new DefaultRhapsodylibxsd_XsdM_line_styleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nHorizontalSpacingFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nHorizontalSpacing] = new DefaultRhapsodylibxsd_XsdM_nHorizontalSpacingFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nInheritanceMaskFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nInheritanceMask] = new DefaultRhapsodylibxsd_XsdM_nInheritanceMaskFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_nVerticalSpacingFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nVerticalSpacing] = new DefaultRhapsodylibxsd_XsdM_nVerticalSpacingFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pImageViewDataFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pImageViewData] = new DefaultRhapsodylibxsd_XsdM_pImageViewDataFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pInheritsFromFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pInheritsFrom] = new DefaultRhapsodylibxsd_XsdM_pInheritsFromFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pSourceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pSource] = new DefaultRhapsodylibxsd_XsdM_pSourceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pTargetFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pTarget] = new DefaultRhapsodylibxsd_XsdM_pTargetFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pointsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_points] = new DefaultRhapsodylibxsd_XsdM_pointsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_providedInterfaceLabelFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_providedInterfaceLabel] = new DefaultRhapsodylibxsd_XsdM_providedInterfaceLabelFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_requiredInterfaceLabelFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_requiredInterfaceLabel] = new DefaultRhapsodylibxsd_XsdM_requiredInterfaceLabelFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_rpnFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_rpn] = new DefaultRhapsodylibxsd_XsdM_rpnFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_showConveyedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_showConveyed] = new DefaultRhapsodylibxsd_XsdM_showConveyedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_sourceTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_sourceType] = new DefaultRhapsodylibxsd_XsdM_sourceTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_srcFileFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_srcFile] = new DefaultRhapsodylibxsd_XsdM_srcFileFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_targetTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_targetType] = new DefaultRhapsodylibxsd_XsdM_targetTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bOrderedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bOrdered] = new DefaultRhapsodylibxsd_XsdM_bOrderedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowInheritedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowInherited] = new DefaultRhapsodylibxsd_XsdM_bShowInheritedFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_itemValueOfFontPropertiesMapCountFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount] = new DefaultRhapsodylibxsd_Xsd_itemValueOfFontPropertiesMapCountFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_fontPropValuesFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_fontPropValues] = new DefaultRhapsodylibxsd_Xsd_fontPropValuesFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_parentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_parent] = new DefaultRhapsodylibxsd_Xsd_parentFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_defaultTransFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_defaultTrans] = new DefaultRhapsodylibxsd_Xsd_defaultTransFormat {}
  implicit lazy val Rhapsodylibxsd_XsdHyperlinksFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdHyperlinks] = new DefaultRhapsodylibxsd_XsdHyperlinksFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIInternalHyperlinkFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIInternalHyperlink] = new DefaultRhapsodylibxsd_XsdIInternalHyperlinkFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_targetFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_target] = new DefaultRhapsodylibxsd_Xsd_targetFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_textTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_textType] = new DefaultRhapsodylibxsd_Xsd_textTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdNAndLineCountFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdNAndLineCount] = new DefaultRhapsodylibxsd_XsdNAndLineCountFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pDefaultComponentRelationFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pDefaultComponentRelation] = new DefaultRhapsodylibxsd_XsdM_pDefaultComponentRelationFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowName] = new DefaultRhapsodylibxsd_XsdM_bShowNameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_multiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_multiplicity] = new DefaultRhapsodylibxsd_XsdM_multiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_csContextFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_csContext] = new DefaultRhapsodylibxsd_XsdM_csContextFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bIsStructuredFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsStructured] = new DefaultRhapsodylibxsd_XsdM_bIsStructuredFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_csPartsArrayFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_csPartsArray] = new DefaultRhapsodylibxsd_XsdM_csPartsArrayFormat {}
  implicit lazy val Rhapsodylibxsd_XsdPortsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdPorts] = new DefaultRhapsodylibxsd_XsdPortsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIConstraintFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIConstraint] = new DefaultRhapsodylibxsd_XsdIConstraintFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_bodyFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_body] = new DefaultRhapsodylibxsd_Xsd_bodyFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIDefaultDrvdTransFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIDefaultDrvdTrans] = new DefaultRhapsodylibxsd_XsdIDefaultDrvdTransFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_errorStatusFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_errorStatus] = new DefaultRhapsodylibxsd_Xsd_errorStatusFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_ofStateFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_ofState] = new DefaultRhapsodylibxsd_Xsd_ofStateFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIForkFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIFork] = new DefaultRhapsodylibxsd_XsdIForkFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_connectorTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_connectorType] = new DefaultRhapsodylibxsd_Xsd_connectorTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIConnectorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIConnector] = new DefaultRhapsodylibxsd_XsdCGIConnectorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdTagsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdTags] = new DefaultRhapsodylibxsd_XsdTagsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bVisibleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bVisible] = new DefaultRhapsodylibxsd_XsdM_bVisibleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIObjectLinkHandleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIObjectLinkHandle] = new DefaultRhapsodylibxsd_XsdIObjectLinkHandleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pInstanceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pInstance] = new DefaultRhapsodylibxsd_XsdM_pInstanceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pInverseInstanceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pInverseInstance] = new DefaultRhapsodylibxsd_XsdM_pInverseInstanceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIAssociationEndHandleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIAssociationEndHandle] = new DefaultRhapsodylibxsd_XsdIAssociationEndHandleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pInverseModelObjectFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pInverseModelObject] = new DefaultRhapsodylibxsd_XsdM_pInverseModelObjectFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowSourceMultiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity] = new DefaultRhapsodylibxsd_XsdM_bShowSourceMultiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowSourceRoleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSourceRole] = new DefaultRhapsodylibxsd_XsdM_bShowSourceRoleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowSpecificTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSpecificType] = new DefaultRhapsodylibxsd_XsdM_bShowSpecificTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowTargetMultiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity] = new DefaultRhapsodylibxsd_XsdM_bShowTargetMultiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowTargetRoleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowTargetRole] = new DefaultRhapsodylibxsd_XsdM_bShowTargetRoleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowLinkNameFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowLinkName] = new DefaultRhapsodylibxsd_XsdM_bShowLinkNameFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowQualifier1Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowQualifier1] = new DefaultRhapsodylibxsd_XsdM_bShowQualifier1Format {}
  implicit lazy val Rhapsodylibxsd_XsdM_bShowQualifier2Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowQualifier2] = new DefaultRhapsodylibxsd_XsdM_bShowQualifier2Format {}
  implicit lazy val Rhapsodylibxsd_XsdM_bInstanceFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bInstance] = new DefaultRhapsodylibxsd_XsdM_bInstanceFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_sourceMultiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_sourceMultiplicity] = new DefaultRhapsodylibxsd_XsdM_sourceMultiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_sourceQualifierFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_sourceQualifier] = new DefaultRhapsodylibxsd_XsdM_sourceQualifierFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_sourceRoleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_sourceRole] = new DefaultRhapsodylibxsd_XsdM_sourceRoleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_specificTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_specificType] = new DefaultRhapsodylibxsd_XsdM_specificTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_targetMultiplicityFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_targetMultiplicity] = new DefaultRhapsodylibxsd_XsdM_targetMultiplicityFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_targetQualifierFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_targetQualifier] = new DefaultRhapsodylibxsd_XsdM_targetQualifierFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_targetRoleFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_targetRole] = new DefaultRhapsodylibxsd_XsdM_targetRoleFormat {}
  implicit lazy val Rhapsodylibxsd_XsdCGIAssociationEndFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGIAssociationEnd] = new DefaultRhapsodylibxsd_XsdCGIAssociationEndFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_bIsMisplacedFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsMisplaced] = new DefaultRhapsodylibxsd_XsdM_bIsMisplacedFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIAnchorFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIAnchor] = new DefaultRhapsodylibxsd_XsdIAnchorFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_moveAndLineTimeStampFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp] = new DefaultRhapsodylibxsd_XsdM_moveAndLineTimeStampFormat {}
  implicit lazy val Rhapsodylibxsd_XsdIInformationItemFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIInformationItem] = new DefaultRhapsodylibxsd_XsdIInformationItemFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_stateTypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_stateType] = new DefaultRhapsodylibxsd_Xsd_stateTypeFormat {}
  implicit lazy val Rhapsodylibxsd_XsdAndLinePolyFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdAndLinePoly] = new DefaultRhapsodylibxsd_XsdAndLinePolyFormat {}
  implicit lazy val Rhapsodylibxsd_XsdM_pVirtualParentFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pVirtualParent] = new DefaultRhapsodylibxsd_XsdM_pVirtualParentFormat {}
  implicit lazy val Rhapsodylibxsd_XsdTransitionsFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdTransitions] = new DefaultRhapsodylibxsd_XsdTransitionsFormat {}
  implicit lazy val Rhapsodylibxsd_XsdEnd1ObjectPortu93Format: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdEnd1ObjectPortu93] = new DefaultRhapsodylibxsd_XsdEnd1ObjectPortu93Format {}
  implicit lazy val Rhapsodylibxsd_XsdIInstanceValueFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIInstanceValue] = new DefaultRhapsodylibxsd_XsdIInstanceValueFormat {}
  implicit lazy val Rhapsodylibxsd_XsdITypeFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIType] = new DefaultRhapsodylibxsd_XsdITypeFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_declarationFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_declaration] = new DefaultRhapsodylibxsd_Xsd_declarationFormat {}
  implicit lazy val Rhapsodylibxsd_Xsd_kindFormat: scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_kind] = new DefaultRhapsodylibxsd_Xsd_kindFormat {}

  def fromAnySchemaTypeHelper1(elem: scala.xml.Elem): Option[scalaxb.DataRecord[Any]] = {
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("_kind"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_kind](elem)))
      case (Some("IType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIType](elem)))
      case (Some("end1ObjectPort_"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdEnd1ObjectPortu93](elem)))
      case (Some("m_pVirtualParent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pVirtualParent](elem)))
      case (Some("_stateType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_stateType](elem)))
      case (Some("m_moveAndLineTimeStamp"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp](elem)))
      case (Some("m_bIsMisplaced"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bIsMisplaced](elem)))
      case (Some("m_targetRole"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_targetRole](elem)))
      case (Some("m_targetMultiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_targetMultiplicity](elem)))
      case (Some("m_sourceRole"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_sourceRole](elem)))
      case (Some("m_sourceMultiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_sourceMultiplicity](elem)))
      case (Some("m_bShowQualifier2"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowQualifier2](elem)))
      case (Some("m_bShowLinkName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowLinkName](elem)))
      case (Some("m_bShowTargetMultiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity](elem)))
      case (Some("m_bShowSourceRole"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowSourceRole](elem)))
      case (Some("m_pInverseModelObject"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pInverseModelObject](elem)))
      case (Some("m_pInverseInstance"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pInverseInstance](elem)))
      case (Some("IObjectLinkHandle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIObjectLinkHandle](elem)))
      case (Some("Tags"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdTags](elem)))
      case (Some("_connectorType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_connectorType](elem)))
      case (Some("_ofState"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_ofState](elem)))
      case (Some("IDefaultDrvdTrans"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIDefaultDrvdTrans](elem)))
      case (Some("IConstraint"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIConstraint](elem)))
      case (Some("m_csPartsArray"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_csPartsArray](elem)))
      case (Some("m_csContext"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_csContext](elem)))
      case (Some("m_bShowName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowName](elem)))
      case (Some("nAndLineCount"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdNAndLineCount](elem)))
      case (Some("_target"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_target](elem)))
      case (Some("Hyperlinks"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdHyperlinks](elem)))
      case (Some("_parent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_parent](elem)))
      case (Some("_itsGuard"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("_fontPropValues"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_fontPropValues](elem)))
      case (Some("m_bShowInherited"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowInherited](elem)))
      case (Some("m_targetType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_targetType](elem)))
      case (Some("m_sourceType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_sourceType](elem)))
      case (Some("m_rpn"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_rpn](elem)))
      case (Some("m_providedInterfaceLabel"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_providedInterfaceLabel](elem)))
      case (Some("m_pTarget"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pTarget](elem)))
      case (Some("m_pInheritsFrom"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](elem)))
      case (Some("m_nVerticalSpacing"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nVerticalSpacing](elem)))
      case (Some("m_nHorizontalSpacing"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nHorizontalSpacing](elem)))
      case (Some("m_keyword"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_keyword](elem)))
      case (Some("m_fileModifiedTime"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_fileModifiedTime](elem)))
      case (Some("m_dataSize"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_dataSize](elem)))
      case (Some("weakCGTime"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdWeakCGTime](elem)))
      case (Some("value"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("lang"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("end2_"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdEnd2u93](elem)))
      case (Some("direction_"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdDirectionu93](elem)))
      case (Some("_typeOf"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_typeOf](elem)))
      case (Some("_static"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_static](elem)))
      case (Some("_otherClass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_otherClass](elem)))
      case (Some("_name"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_name2](elem)))
      case (Some("_multiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_multiplicity](elem)))
      case (Some("_modifiedTime"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](elem)))
      case (Some("_lastID"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_lastID](elem)))
      case (Some("_isVirtual"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_isVirtual](elem)))
      case (Some("_isOrdered"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_isOrdered](elem)))
      case (Some("_inverse"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_inverse](elem)))
      case (Some("_implicitClass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_implicitClass](elem)))
      case (Some("_hsubsystem"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hsubsystem](elem)))
      case (Some("_hm2Class"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hm2Class](elem)))
      case (Some("_hfilename"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hfilename](elem)))
      case (Some("_displayName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_displayName](elem)))
      case (Some("_dependsOn"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_dependsOn](elem)))
      case (Some("_classModifier"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_classModifier](elem)))
      case (Some("Stereotypes"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdStereotypes](elem)))
      case (Some("RhapsodyArchive"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdRhapsodyArchive](elem)))
      case (Some("RHAPSODY-MODEL"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL](elem)))
      case (Some("ITransition"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdITransition](elem)))
      case (Some("CGITrans"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGITrans](elem)))
      case (Some("CGIImage"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIImage](elem)))
      case (Some("CGIStateChart"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIStateChart](elem)))
      case (Some("_staticReaction"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_staticReaction](elem)))
      case (Some("m_bShowKeyword"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowKeyword](elem)))
      case (Some("m_conveyed"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_conveyed](elem)))
      case (Some("CGIClass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIClass](elem)))
      case (Some("CGIImageData"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIImageData](elem)))
      case (Some("m_arrow"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_arrow](elem)))
      case (Some("m_SourcePort"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_SourcePort](elem)))
      case (Some("m_ShowName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_ShowName](elem)))
      case (Some("m_anglePoint1"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_anglePoint1](elem)))
      case (Some("m_bFramesetModified"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bFramesetModified](elem)))
      case (Some("m_nNameFormat"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](elem)))
      case (Some("Operations"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdOperations](elem)))
      case (Some("OslcLinks"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdOslcLinks](elem)))
      case (Some("IStateChartDiagram"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIStateChartDiagram](elem)))
      case (Some("ISysMLPort"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdISysMLPort](elem)))
      case (Some("IPort"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIPort](elem)))
      case (Some("INObjectHandle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdINObjectHandle](elem)))
      case (Some("ILiteralSpecification"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdILiteralSpecification](elem)))
      case (Some("IHandle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIHandle](elem)))
      case (Some("IStateChart"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIStateChart](elem)))
      case (Some("_baseVersion"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_baseVersion](elem)))
      case (Some("_defNumber"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_defNumber](elem)))
      case (Some("IClassifierHandle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIClassifierHandle](elem)))
      case (Some("IAttribute"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIAttribute](elem)))
      case (Some("IAssociationEnd"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIAssociationEnd](elem)))
      case (Some("Conveyed"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdConveyed](elem)))
      case (Some("BuildNo"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Long](elem)))
      case (Some("AggregatesList"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdAggregatesList](elem)))
      case (Some("_description"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_description](elem)))
      case (Some("_textRTF"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_textRTF](elem)))
      case (Some("CGIDiagramFrame"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIDiagramFrame](elem)))
      case (Some("m_SubType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_SubType](elem)))
      case (Some("_linkTarget"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_linkTarget](elem)))
      case (Some("isConfigurationFileHyperLink"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink](elem)))
      case (Some("IProperty"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIProperty](elem)))
      case (Some("IPropertyContainer"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIPropertyContainer](elem)))
      case (Some("IPropertySubject"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIPropertySubject](elem)))
      case (Some("Properties"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdProperties](elem)))
      case (Some("_Name"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_Name](elem)))
      case (Some("_rmmServerID"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](elem)))
      case (Some("_properties"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_properties](elem)))
      case (Some("IComment"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIComment](elem)))
      case (Some("m_access"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_access](elem)))
      case (Some("m_bFreezeCompartmentContent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent](elem)))
      case (Some("m_bIsPreferencesInitialized"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](elem)))
      case (Some("m_bgColor"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bgColor](elem)))
      case (Some("m_color"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_color](elem)))
      case (Some("CGIGenericElement"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIGenericElement](elem)))
      case (Some("Items"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdItems](elem)))
      case (Some("_iTempdisplayTextFlag"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag](elem)))
      case (Some("m_str"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_str](elem)))
      case (Some("IColor"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIColor](elem)))
      case (Some("m_currentRightBottom"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_currentRightBottom](elem)))
      case (Some("m_fgColor"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_fgColor](elem)))
      case (Some("m_nCreateDate"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nCreateDate](elem)))
      case (Some("m_nModifyDate"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nModifyDate](elem)))
      case (Some("m_name"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_name](elem)))
      case (Some("m_pParent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pParent](elem)))
      case (Some("m_position"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_position](elem)))
      case (Some("m_type"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_type](elem)))
      case (Some("m_hReferencedDiagram"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_hReferencedDiagram](elem)))

      case _ => None
    }
  }

  def fromAnySchemaTypeHelper2(elem: scala.xml.Elem): Option[scalaxb.DataRecord[Any]] = {
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("_lastModifiedTime"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_lastModifiedTime](elem)))
      case (Some("m_style"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_style](elem)))
      case (Some("m_pRoot"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pRoot](elem)))
      case (Some("m_pModelObject"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pModelObject](elem)))
      case (Some("m_nOrientationCtrlPt"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nOrientationCtrlPt](elem)))
      case (Some("m_nIdent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nIdent](elem)))
      case (Some("m_modified"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_modified](elem)))
      case (Some("m_drawBehavior"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](elem)))
      case (Some("m_currentLeftTop"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_currentLeftTop](elem)))
      case (Some("m_displayOption"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_displayOption](elem)))
      case (Some("CGIText"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIText](elem)))
      case (Some("m_bIsBoxStyle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bIsBoxStyle](elem)))
      case (Some("CGIAnnotation"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIAnnotation](elem)))
      case (Some("CGICompartment"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGICompartment](elem)))
      case (Some("m_bgFlag"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bgFlag](elem)))
      case (Some("m_bScaleWithZoom"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bScaleWithZoom](elem)))
      case (Some("m_bImplicitSetRectPoints"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints](elem)))
      case (Some("m_arrowStyle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_arrowStyle](elem)))
      case (Some("elementList"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdElementList](elem)))
      case (Some("_defaultSubsystem"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_defaultSubsystem](elem)))
      case (Some("_Value"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_Value](elem)))
      case (Some("_Type"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_Type](elem)))
      case (Some("Subjects"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdSubjects](elem)))
      case (Some("Metaclasses"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdMetaclasses](elem)))
      case (Some("IPropertyMetaclass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIPropertyMetaclass](elem)))
      case (Some("_ExtraTypeInfo"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_ExtraTypeInfo](elem)))
      case (Some("IMSC"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIMSC](elem)))
      case (Some("m_transform"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_transform](elem)))
      case (Some("_linkDispName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_linkDispName](elem)))
      case (Some("CGIPortConnector"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIPortConnector](elem)))
      case (Some("IMHyperLink"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIMHyperLink](elem)))
      case (Some("_text"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_text](elem)))
      case (Some("IDescription"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIDescription](elem)))
      case (Some("size"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdSize](elem)))
      case (Some("CODE-PAGE"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Short](elem)))
      case (Some("Associations"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdAssociations](elem)))
      case (Some("IDiagram"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIDiagram](elem)))
      case (Some("IClass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIClass](elem)))
      case (Some("IDependency"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIDependency](elem)))
      case (Some("_version"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_version](elem)))
      case (Some("_diagram"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_diagram](elem)))
      case (Some("IGeneralization"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIGeneralization](elem)))
      case (Some("IInformationFlow"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIInformationFlow](elem)))
      case (Some("INCLUDES-RHAPSODY-INDEX"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Boolean](elem)))
      case (Some("IPart"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIPart](elem)))
      case (Some("IRPYRawContainer"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](elem)))
      case (Some("ITag"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdITag](elem)))
      case (Some("MagicNumber"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdMagicNumber](elem)))
      case (Some("OwnedDependencies"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdOwnedDependencies](elem)))
      case (Some("m_AdditionalLabel"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](elem)))
      case (Some("m_nIsNameFormat"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](elem)))
      case (Some("frameset"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdFrameset](elem)))
      case (Some("m_anglePoint2"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_anglePoint2](elem)))
      case (Some("m_ShowStereotype"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_ShowStereotype](elem)))
      case (Some("m_TargetPort"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_TargetPort](elem)))
      case (Some("m_polygon"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_polygon](elem)))
      case (Some("CGIObjectInstance"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIObjectInstance](elem)))
      case (Some("Attrs"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdAttrs](elem)))
      case (Some("_itsTarget"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_itsTarget](elem)))
      case (Some("_itsSource"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_itsSource](elem)))
      case (Some("CGIState"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIState](elem)))
      case (Some("CGIClassChart"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIClassChart](elem)))
      case (Some("CGIInheritance"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIInheritance](elem)))
      case (Some("CGIInformationFlow"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIInformationFlow](elem)))
      case (Some("ILabel"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdILabel](elem)))
      case (Some("RMMMinimumClientVersion"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BigDecimal](elem)))
      case (Some("IState"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIState](elem)))
      case (Some("_base"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_base](elem)))
      case (Some("_dependent"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_dependent](elem)))
      case (Some("_direction"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_direction](elem)))
      case (Some("_hclass"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hclass](elem)))
      case (Some("_hid"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hid](elem)))
      case (Some("_hname"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_hname](elem)))
      case (Some("_id"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_id](elem)))
      case (Some("_inheritanceType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_inheritanceType](elem)))
      case (Some("_isConstant"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_isConstant](elem)))
      case (Some("_isReferenceAttr"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_isReferenceAttr](elem)))
      case (Some("_itsStateChart"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_itsStateChart](elem)))
      case (Some("_linkType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_linkType](elem)))
      case (Some("_modifiedTimeWeak"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](elem)))
      case (Some("_myState"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_myState](elem)))
      case (Some("_navigability"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_navigability](elem)))
      case (Some("_protection"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_protection](elem)))
      case (Some("_theMainDiagram"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_theMainDiagram](elem)))
      case (Some("_value"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_value2](elem)))
      case (Some("end1_"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdEnd1u93](elem)))
      case (Some("fileName"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdFileName](elem)))
      case (Some("strongCGTime"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdStrongCGTime](elem)))
      case (Some("version"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("m_data"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_data](elem)))
      case (Some("m_direction"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_direction](elem)))
      case (Some("m_flow_direction"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_flow_direction](elem)))
      case (Some("m_line_style"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_line_style](elem)))
      case (Some("m_nInheritanceMask"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](elem)))
      case (Some("m_pImageViewData"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pImageViewData](elem)))
      case (Some("m_pSource"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pSource](elem)))
      case (Some("m_points"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_points](elem)))
      case (Some("m_requiredInterfaceLabel"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_requiredInterfaceLabel](elem)))
      case (Some("m_showConveyed"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_showConveyed](elem)))
      case (Some("m_srcFile"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_srcFile](elem)))
      case (Some("m_bOrdered"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bOrdered](elem)))
      case (Some("_itemValueOfFontPropertiesMapCount"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount](elem)))
      case (Some("_itsAction"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("_itsTrigger"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("_defaultTrans"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_defaultTrans](elem)))
      case (Some("IInternalHyperlink"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIInternalHyperlink](elem)))
      case (Some("_textType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_textType](elem)))
      case (Some("m_pDefaultComponentRelation"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pDefaultComponentRelation](elem)))
      case (Some("m_multiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_multiplicity](elem)))
      case (Some("m_bIsStructured"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bIsStructured](elem)))
      case (Some("Ports"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdPorts](elem)))
      case (Some("_body"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_body](elem)))
      case (Some("_errorStatus"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_errorStatus](elem)))
      case (Some("IFork"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIFork](elem)))
      case (Some("CGIConnector"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIConnector](elem)))
      case (Some("m_bVisible"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bVisible](elem)))
      case (Some("m_pInstance"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_pInstance](elem)))
      case (Some("IAssociationEndHandle"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIAssociationEndHandle](elem)))
      case (Some("m_bShowSourceMultiplicity"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity](elem)))
      case (Some("m_bShowSpecificType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowSpecificType](elem)))
      case (Some("m_bShowTargetRole"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowTargetRole](elem)))
      case (Some("m_bShowQualifier1"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bShowQualifier1](elem)))
      case (Some("m_bInstance"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_bInstance](elem)))
      case (Some("m_sourceQualifier"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_sourceQualifier](elem)))
      case (Some("m_specificType"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_specificType](elem)))
      case (Some("m_targetQualifier"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdM_targetQualifier](elem)))
      case (Some("CGIAssociationEnd"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdCGIAssociationEnd](elem)))
      case (Some("IAnchor"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIAnchor](elem)))
      case (Some("IInformationItem"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIInformationItem](elem)))
      case (Some("andLinePoly"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdAndLinePoly](elem)))
      case (Some("Transitions"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdTransitions](elem)))
      case (Some("IInstanceValue"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.XsdIInstanceValue](elem)))
      case (Some("_declaration"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rhapsody.lib.xsd.Xsd_declaration](elem)))

      case _ => None
    }
  }


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    fromAnySchemaTypeHelper1(elem) match {
      case None => fromAnySchemaTypeHelper2(elem)
      case result => result
    }
  }

  trait DefaultRhapsodylibxsd_XsdM_hReferencedDiagramFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_hReferencedDiagram] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_hReferencedDiagram] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_hReferencedDiagram(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_hReferencedDiagram, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_hReferencedDiagram, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_lastModifiedTimeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_lastModifiedTime] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_lastModifiedTime] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_lastModifiedTime] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_lastModifiedTime(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_lastModifiedTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_lastModifiedTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_typeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_type] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_type] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_type(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_styleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_style] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_style] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_style] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_style(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_positionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_position] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_position] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_position] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_position(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_position, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_position, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pRootFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pRoot] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pRoot] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pRoot] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pRoot(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pRoot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pRoot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pParentFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pParent] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pParent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pParent] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pParent(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pParent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pParent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pModelObjectFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pModelObject] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pModelObject] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pModelObject(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pModelObject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pModelObject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_nameFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_name] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_name] =
      phrase(optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "CGIText")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      rhapsody.lib.xsd.XsdM_name(Seq.concat(p1.toList,
        p2.toList,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultRhapsodylibxsd_XsdM_nOrientationCtrlPtFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nOrientationCtrlPt] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nOrientationCtrlPt] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nOrientationCtrlPt] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nOrientationCtrlPt(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nOrientationCtrlPt, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nOrientationCtrlPt, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nModifyDateFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nModifyDate] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nModifyDate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nModifyDate] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nModifyDate(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nModifyDate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nModifyDate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nIdentFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nIdent] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nIdent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nIdent] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nIdent(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nIdent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nIdent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nCreateDateFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nCreateDate] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nCreateDate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nCreateDate] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nCreateDate(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nCreateDate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nCreateDate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_modifiedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_modified] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_modified] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_modified] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_modified(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_modified, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_modified, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_fgColorFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_fgColor] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_fgColor] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_fgColor] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_fgColor(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_fgColor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_fgColor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_drawBehaviorFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_drawBehavior] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_drawBehavior] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_drawBehavior] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_drawBehavior(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_drawBehavior, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_drawBehavior, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_currentRightBottomFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_currentRightBottom] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_currentRightBottom] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_currentRightBottom] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_currentRightBottom(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_currentRightBottom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_currentRightBottom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_currentLeftTopFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_currentLeftTop] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_currentLeftTop] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_currentLeftTop] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_currentLeftTop(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_currentLeftTop, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_currentLeftTop, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIColorFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIColor] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIColor] =
      phrase((scalaxb.ElemName(None, "m_fgColor")) ~ 
      (scalaxb.ElemName(None, "m_bgColor")) ~ 
      (scalaxb.ElemName(None, "m_bgFlag")) ^^
      { case p1 ~ p2 ~ p3 =>
      rhapsody.lib.xsd.XsdIColor(scalaxb.fromXML[rhapsody.lib.xsd.XsdM_fgColor](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bgColor](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bgFlag](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIColor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIColor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.XsdM_fgColor](__obj.m_fgColor, None, Some("m_fgColor"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bgColor](__obj.m_bgColor, None, Some("m_bgColor"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bgFlag](__obj.m_bgFlag, None, Some("m_bgFlag"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_displayOptionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_displayOption] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_displayOption] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_displayOption] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_displayOption(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_displayOption, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_displayOption, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_strFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_str] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_str] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_str] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_str(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_str, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_str, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdCGITextFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIText] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIText] =
      phrase(safeRep(((scalaxb.ElemName(None, "m_str")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_str](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_style")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_style](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_color")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_color](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_position")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_position](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_nIdent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIdent](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_bImplicitSetRectPoints")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((opt(scalaxb.ElemName(None, "m_nHorizontalSpacing")) ~ 
      (scalaxb.ElemName(None, "m_nVerticalSpacing"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(rhapsody.lib.xsd.XsdCGITextSequence1(p1.headOption map { scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nHorizontalSpacing](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nVerticalSpacing](p2, scalaxb.ElemName(node) :: stack))) }) ||| 
      ((scalaxb.ElemName(None, "m_nOrientationCtrlPt")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nOrientationCtrlPt](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIText(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIText, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIText, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgitextoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGITextOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGITextSequence1Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdCGITextSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdCGITextSequence1] = Left("don't call me.")
    
    def writes(__obj: rhapsody.lib.xsd.XsdCGITextSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.m_nHorizontalSpacing map { scalaxb.toXML[rhapsody.lib.xsd.XsdM_nHorizontalSpacing](_, None, Some("m_nHorizontalSpacing"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nVerticalSpacing](__obj.m_nVerticalSpacing, None, Some("m_nVerticalSpacing"), __scope, false))


  }

  trait DefaultRhapsodylibxsd_Xsd_iTempdisplayTextFlagFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bIsBoxStyleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsBoxStyle] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bIsBoxStyle] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bIsBoxStyle] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bIsBoxStyle(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bIsBoxStyle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bIsBoxStyle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdItemsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdItems] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdItems] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdItems(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdItems, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdItems, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIAnnotationFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIAnnotation] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIAnnotation] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_transform")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "m_AdditionalLabel")) ~ 
      (scalaxb.ElemName(None, "m_polygon")) ~ 
      (scalaxb.ElemName(None, "m_nNameFormat")) ~ 
      (scalaxb.ElemName(None, "m_nIsNameFormat")) ~ 
      (scalaxb.ElemName(None, "_iTempdisplayTextFlag")) ~ 
      (scalaxb.ElemName(None, "m_bIsBoxStyle")) ~ 
      (scalaxb.ElemName(None, "AggregatesList")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 =>
      rhapsody.lib.xsd.XsdCGIAnnotation(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](p12, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag](p13, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsBoxStyle](p14, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](p15, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIAnnotation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIAnnotation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_transform](__obj.m_transform, None, Some("m_transform"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](__obj.m_AdditionalLabel, None, Some("m_AdditionalLabel"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_polygon](__obj.m_polygon, None, Some("m_polygon"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nNameFormat](__obj.m_nNameFormat, None, Some("m_nNameFormat"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](__obj.m_nIsNameFormat, None, Some("m_nIsNameFormat"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_iTempdisplayTextFlag](__obj._iTempdisplayTextFlag, None, Some("_iTempdisplayTextFlag"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsBoxStyle](__obj.m_bIsBoxStyle, None, Some("m_bIsBoxStyle"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAggregatesList](__obj.AggregatesList, None, Some("AggregatesList"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIGenericElementFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIGenericElement] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIGenericElement] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_AdditionalLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_polygon")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nIsNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "frameset")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdFrameset](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_csContext")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_csContext](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsStructured")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsStructured](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_csPartsArray")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_csPartsArray](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsMisplaced")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsMisplaced](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIGenericElement(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIGenericElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIGenericElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgigenericelementoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIGenericElementOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGICompartmentFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGICompartment] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGICompartment] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_displayOption")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_displayOption](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowInherited")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowInherited](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bOrdered")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bOrdered](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_itemValueOfFontPropertiesMapCount")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_fontPropValues")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_fontPropValues](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Items")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdItems](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGICompartment(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGICompartment, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGICompartment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgicompartmentoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGICompartmentOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdM_colorFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_color] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_color] =
      phrase((scalaxb.ElemName(None, "IColor")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_color(scalaxb.fromXML[rhapsody.lib.xsd.XsdIColor](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_color, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_color, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIColor](__obj.IColor, None, Some("IColor"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_bgFlagFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bgFlag] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bgFlag] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bgFlag] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bgFlag(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bgFlag, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bgFlag, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bgColorFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bgColor] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bgColor] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bgColor] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bgColor(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bgColor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bgColor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bScaleWithZoomFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bScaleWithZoom] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bScaleWithZoom] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bScaleWithZoom] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bScaleWithZoom(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bScaleWithZoom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bScaleWithZoom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bIsPreferencesInitializedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bImplicitSetRectPointsFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bImplicitSetRectPoints, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bFreezeCompartmentContentFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_arrowStyleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_arrowStyle] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_arrowStyle] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_arrowStyle] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_arrowStyle(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_arrowStyle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_arrowStyle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_accessFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_access] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_access] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_access] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_access(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_access, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_access, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdElementListFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdElementList] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdElementList] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdElementList] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdElementList(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdElementList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdElementList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdICommentFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIComment] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIComment] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIComment(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIComment, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIComment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdicommentoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdICommentOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_defaultSubsystemFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_defaultSubsystem] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_defaultSubsystem] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_defaultSubsystem(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_defaultSubsystem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_defaultSubsystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_propertiesFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_properties] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_properties] =
      phrase((scalaxb.ElemName(None, "IPropertyContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_properties(scalaxb.fromXML[rhapsody.lib.xsd.XsdIPropertyContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_properties, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_properties, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIPropertyContainer](__obj.IPropertyContainer, None, Some("IPropertyContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_ValueFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Value] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_Value] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_Value] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_Value(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_Value, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_Value, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_rmmServerIDFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_rmmServerID] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_rmmServerID] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_rmmServerID] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_rmmServerID(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_rmmServerID, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_rmmServerID, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_TypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Type] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_Type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_Type] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_Type(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_Type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_Type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_NameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_Name] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_Name] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_Name] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_Name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_Name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_Name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdSubjectsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdSubjects] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdSubjects] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdSubjects(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdSubjects, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdSubjects, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdPropertiesFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdProperties] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdProperties] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdProperties(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdProperties, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdProperties, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdMetaclassesFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdMetaclasses] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdMetaclasses] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdMetaclasses(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdMetaclasses, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdMetaclasses, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIPropertySubjectFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIPropertySubject] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIPropertySubject] =
      phrase((scalaxb.ElemName(None, "_Name")) ~ 
      (scalaxb.ElemName(None, "Metaclasses")) ^^
      { case p1 ~ p2 =>
      rhapsody.lib.xsd.XsdIPropertySubject(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_Name](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdMetaclasses](p2, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIPropertySubject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIPropertySubject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_Name](__obj._Name, None, Some("_Name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdMetaclasses](__obj.Metaclasses, None, Some("Metaclasses"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIPropertyMetaclassFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIPropertyMetaclass] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIPropertyMetaclass] =
      phrase((scalaxb.ElemName(None, "_Name")) ~ 
      (scalaxb.ElemName(None, "Properties")) ^^
      { case p1 ~ p2 =>
      rhapsody.lib.xsd.XsdIPropertyMetaclass(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_Name](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdProperties](p2, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIPropertyMetaclass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIPropertyMetaclass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_Name](__obj._Name, None, Some("_Name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdProperties](__obj.Properties, None, Some("Properties"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIPropertyContainerFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIPropertyContainer] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIPropertyContainer] =
      phrase((scalaxb.ElemName(None, "Subjects")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIPropertyContainer(scalaxb.fromXML[rhapsody.lib.xsd.XsdSubjects](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIPropertyContainer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIPropertyContainer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdSubjects](__obj.Subjects, None, Some("Subjects"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_ExtraTypeInfoFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_ExtraTypeInfo] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_ExtraTypeInfo] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_ExtraTypeInfo] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_ExtraTypeInfo(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_ExtraTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_ExtraTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIPropertyFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIProperty] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIProperty] =
      phrase(safeRep(((scalaxb.ElemName(None, "_Name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_Name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_Value")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_Value](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_Type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_Type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_ExtraTypeInfo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_ExtraTypeInfo](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIProperty(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIProperty, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIProperty, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdipropertyoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIPropertyOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIMSCFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIMSC] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIMSC] =
      phrase((scalaxb.ElemName(None, "fileName")) ~ 
      (scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_name")) ^^
      { case p1 ~ p2 ~ p3 =>
      rhapsody.lib.xsd.XsdIMSC(scalaxb.fromXML[rhapsody.lib.xsd.XsdFileName](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIMSC, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIMSC, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.XsdFileName](__obj.fileName, None, Some("fileName"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIsConfigurationFileHyperLinkFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_transformFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_transform] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_transform] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_transform] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_transform(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_transform, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_transform, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_linkTargetFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkTarget] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_linkTarget] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_linkTarget] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_linkTarget(scalaxb.fromXML[java.net.URI](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_linkTarget, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_linkTarget, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_linkDispNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkDispName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_linkDispName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_linkDispName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_linkDispName(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_linkDispName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_linkDispName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_SubTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_SubType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_SubType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_SubType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_SubType(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_SubType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_SubType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdCGIPortConnectorFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIPortConnector] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIPortConnector] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_AdditionalLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_position")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_position](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pInheritsFrom")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nInheritanceMask")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_SubType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SubType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_providedInterfaceLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_providedInterfaceLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_requiredInterfaceLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_requiredInterfaceLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bVisible")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bVisible](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIPortConnector(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIPortConnector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIPortConnector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiportconnectoroption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIPortConnectorOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGIDiagramFrameFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIDiagramFrame] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIDiagramFrame] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_AdditionalLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_polygon")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nIsNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bVisible")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bVisible](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIDiagramFrame(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIDiagramFrame, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIDiagramFrame, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgidiagramframeoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIDiagramFrameOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIMHyperLinkFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIMHyperLink] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIMHyperLink] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_dependsOn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_dependsOn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_linkDispName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_linkDispName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_linkType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_linkType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_linkTarget")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_linkTarget](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "isConfigurationFileHyperLink")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIsConfigurationFileHyperLink](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIMHyperLink(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIMHyperLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIMHyperLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdimhyperlinkoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIMHyperLinkOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_textRTFFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_textRTF] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_textRTF] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_textRTF] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_textRTF(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_textRTF, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_textRTF, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_textFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_text] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_text] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_descriptionFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_description] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_description] =
      phrase((scalaxb.ElemName(None, "IDescription")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_description(scalaxb.fromXML[rhapsody.lib.xsd.XsdIDescription](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_description, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_description, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIDescription](__obj.IDescription, None, Some("IDescription"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIDescriptionFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIDescription] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIDescription] =
      phrase(safeRep(((scalaxb.ElemName(None, "_textRTF")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_textRTF](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Hyperlinks")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdHyperlinks](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIDescription(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIDescription, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIDescription, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdidescriptionoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIDescriptionOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdAggregatesListFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdAggregatesList] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdAggregatesList] =
      phrase(safeRep(scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdAggregatesList(p1 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdAggregatesList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdAggregatesList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.value flatMap { scalaxb.toXML[String](_, None, Some("value"), __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdSizeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdSize] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdSize] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdSize] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdSize(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdSize, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdSize, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdConveyedFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdConveyed] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdConveyed] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdConveyed(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdConveyed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdConveyed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdAssociationsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdAssociations] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdAssociations] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdAssociations(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdAssociations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdAssociations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIAssociationEndFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIAssociationEnd] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIAssociationEnd] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_multiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_multiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_otherClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_otherClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_inverse")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_inverse](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_linkType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_linkType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_navigability")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_navigability](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIAssociationEnd(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIAssociationEnd, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIAssociationEnd, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiassociationendoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIAssociationEndOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIDiagramFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIDiagram] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIDiagram] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastModifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastModifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_hReferencedDiagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_hReferencedDiagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_defaultSubsystem")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_defaultSubsystem](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIDiagram(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIDiagram, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIDiagram, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdidiagramoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIDiagramOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIAttributeFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIAttribute] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIAttribute] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_typeOf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_typeOf](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_isOrdered")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_isOrdered](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_protection")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_protection](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_static")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_static](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_isReferenceAttr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_isReferenceAttr](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_isConstant")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_isConstant](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "OwnedDependencies")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdOwnedDependencies](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Tags")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdTags](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIAttribute(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIAttribute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIAttribute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiattributeoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIAttributeOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIClassFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIClass] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIClass] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_theMainDiagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_theMainDiagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "weakCGTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdWeakCGTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "strongCGTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStrongCGTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_itsStateChart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsStateChart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_classModifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_classModifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "OwnedDependencies")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdOwnedDependencies](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fileName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdFileName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Associations")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAssociations](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Ports")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdPorts](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIClass(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIClass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIClass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiclassoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIClassOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIClassifierHandleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIClassifierHandle] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIClassifierHandle] =
      phrase(safeRep(((scalaxb.ElemName(None, "_hm2Class")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hm2Class](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hfilename")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hfilename](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hsubsystem")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hsubsystem](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hclass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hclass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hname")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hname](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hid")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hid](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIClassifierHandle(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIClassifierHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIClassifierHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiclassifierhandleoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIClassifierHandleOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIDependencyFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIDependency] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIDependency] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_dependsOn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_dependsOn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_dependent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_dependent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIDependency(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIDependency, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIDependency, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdidependencyoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIDependencyOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_defNumberFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_defNumber] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_defNumber] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_defNumber] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_defNumber(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_defNumber, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_defNumber, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_versionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_version] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_version] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_version] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_version(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_version, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_version, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_baseVersionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_baseVersion] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_baseVersion] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_baseVersion] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_baseVersion(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_baseVersion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_baseVersion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_diagramFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_diagram] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_diagram] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_diagram] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_diagram(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_diagram, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_diagram, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIStateChartFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIStateChart] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIStateChart] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "weakCGTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdWeakCGTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "strongCGTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStrongCGTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_itsStateChart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsStateChart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_classModifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_classModifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_defNumber")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_defNumber](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_version")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_version](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_baseVersion")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_baseVersion](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_diagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_diagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Transitions")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdTransitions](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIStateChart(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIStateChart, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIStateChart, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdistatechartoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIStateChartOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIGeneralizationFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIGeneralization] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIGeneralization] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_dependsOn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_dependsOn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_inheritanceType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_inheritanceType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_isVirtual")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_isVirtual](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIGeneralization(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIGeneralization, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIGeneralization, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdigeneralizationoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIGeneralizationOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIHandleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIHandle] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIHandle] =
      phrase(opt(((scalaxb.ElemName(None, "_hm2Class")) ~ 
      safeRep(((scalaxb.ElemName(None, "_hfilename")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hfilename](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hsubsystem")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hsubsystem](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hclass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hclass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hname")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hname](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_hid")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hid](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => rhapsody.lib.xsd.XsdIHandleSequence1(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hm2Class](p1, scalaxb.ElemName(node) :: stack),
        p2) }) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIHandle(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdihandlesequence1 map { scalaxb.toXML[rhapsody.lib.xsd.XsdIHandleSequence1](_, None, Some("xsdihandlesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultRhapsodylibxsd_XsdIHandleSequence1Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIHandleSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdIHandleSequence1] = Left("don't call me.")
    
    def writes(__obj: rhapsody.lib.xsd.XsdIHandleSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_hm2Class](__obj._hm2Class, None, Some("_hm2Class"), __scope, false),
        __obj.xsdihandleoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIHandleOption]](x, x.namespace, x.key, __scope, false) })


  }

  trait DefaultRhapsodylibxsd_XsdIInformationFlowFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIInformationFlow] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIInformationFlow] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Conveyed")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdConveyed](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "end1_")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdEnd1u93](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "end2_")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdEnd2u93](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "direction_")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdDirectionu93](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "end1ObjectPort_")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdEnd1ObjectPortu93](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIInformationFlow(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIInformationFlow, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIInformationFlow, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiinformationflowoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIInformationFlowOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdILiteralSpecificationFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdILiteralSpecification] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdILiteralSpecification] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_value")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_value2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdILiteralSpecification(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdILiteralSpecification, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdILiteralSpecification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiliteralspecificationoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdILiteralSpecificationOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdINObjectHandleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdINObjectHandle] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdINObjectHandle] =
      phrase(opt(((scalaxb.ElemName(None, "_hm2Class")) ~ 
      ((((scalaxb.ElemName(None, "_hfilename")) ~ 
      (scalaxb.ElemName(None, "_hsubsystem")) ~ 
      opt(scalaxb.ElemName(None, "_hclass")) ~ 
      (scalaxb.ElemName(None, "_hname")) ~ 
      (scalaxb.ElemName(None, "_hid"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => scalaxb.DataRecord(rhapsody.lib.xsd.XsdINObjectHandleSequence2(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hfilename](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hsubsystem](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hclass](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hname](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hid](p5, scalaxb.ElemName(node) :: stack))) }) ||| 
      ((scalaxb.ElemName(None, "_hid")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hid](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => rhapsody.lib.xsd.XsdINObjectHandleSequence1(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hm2Class](p1, scalaxb.ElemName(node) :: stack),
        p2) }) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdINObjectHandle(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdINObjectHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdINObjectHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdinobjecthandlesequence1 map { scalaxb.toXML[rhapsody.lib.xsd.XsdINObjectHandleSequence1](_, None, Some("xsdinobjecthandlesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultRhapsodylibxsd_XsdINObjectHandleSequence2Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdINObjectHandleSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdINObjectHandleSequence2] = Left("don't call me.")
    
    def writes(__obj: rhapsody.lib.xsd.XsdINObjectHandleSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_hfilename](__obj._hfilename, None, Some("_hfilename"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hsubsystem](__obj._hsubsystem, None, Some("_hsubsystem"), __scope, false),
        __obj._hclass map { scalaxb.toXML[rhapsody.lib.xsd.Xsd_hclass](_, None, Some("_hclass"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hname](__obj._hname, None, Some("_hname"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hid](__obj._hid, None, Some("_hid"), __scope, false))


  }

  trait DefaultRhapsodylibxsd_XsdINObjectHandleSequence1Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdINObjectHandleSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdINObjectHandleSequence1] = Left("don't call me.")
    
    def writes(__obj: rhapsody.lib.xsd.XsdINObjectHandleSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_hm2Class](__obj._hm2Class, None, Some("_hm2Class"), __scope, false),
        (Some(__obj.xsdinobjecthandleoption) map {x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdINObjectHandleOption]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultRhapsodylibxsd_XsdIPartFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIPart] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIPart] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_multiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_multiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_otherClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_otherClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_inverse")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_inverse](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fileName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdFileName](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIPart(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIPart, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIPart, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdipartoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIPartOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIPortFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIPort] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIPort] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_multiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_multiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_otherClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_otherClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_inverse")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_inverse](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIPort(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiportoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIPortOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIRPYRawContainerFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIRPYRawContainer] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIRPYRawContainer] =
      phrase(safeRep(((scalaxb.ElemName(None, "size")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdSize](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IHandle")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IProperty")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIProperty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IPropertyMetaclass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIPropertyMetaclass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IPropertySubject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIPropertySubject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IInternalHyperlink")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIInternalHyperlink](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIRPYRawContainer(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIRPYRawContainer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIRPYRawContainer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdirpyrawcontaineroption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIRPYRawContainerOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdISysMLPortFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdISysMLPort] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdISysMLPort] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_multiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_multiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_otherClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_otherClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_inverse")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_inverse](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_implicitClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_implicitClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdISysMLPort(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdISysMLPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdISysMLPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdisysmlportoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdISysMLPortOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdITagFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdITag] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdITag] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_typeOf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_typeOf](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_isOrdered")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_isOrdered](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "_multiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_multiplicity](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((scalaxb.ElemName(None, "_base")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_base](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdITag(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdITag, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdITag, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsditagoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdITagOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdIStateChartDiagramFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIStateChartDiagram] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIStateChartDiagram] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastModifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastModifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_hReferencedDiagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_hReferencedDiagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIStateChartDiagram(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIStateChartDiagram, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIStateChartDiagram, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdistatechartdiagramoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIStateChartDiagramOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdMagicNumberFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdMagicNumber] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdMagicNumber] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdMagicNumber] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdMagicNumber())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdMagicNumber, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultRhapsodylibxsd_XsdOslcLinksFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdOslcLinks] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdOslcLinks] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdOslcLinks(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdOslcLinks, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdOslcLinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdOwnedDependenciesFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdOwnedDependencies] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdOwnedDependencies] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdOwnedDependencies(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdOwnedDependencies, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdOwnedDependencies, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdOperationsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdOperations] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdOperations] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdOperations(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdOperations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdOperations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_AdditionalLabelFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_AdditionalLabel] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_AdditionalLabel] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_AdditionalLabel(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_AdditionalLabel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_AdditionalLabel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_nNameFormatFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nNameFormat] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nNameFormat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nNameFormat] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nNameFormat(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nNameFormat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nNameFormat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nIsNameFormatFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nIsNameFormat] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nIsNameFormat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nIsNameFormat] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nIsNameFormat(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nIsNameFormat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nIsNameFormat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bFramesetModifiedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bFramesetModified] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bFramesetModified] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bFramesetModified] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bFramesetModified(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bFramesetModified, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bFramesetModified, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdFramesetFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdFrameset] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdFrameset] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdFrameset] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdFrameset(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdFrameset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdFrameset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_anglePoint1Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_anglePoint1] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_anglePoint1] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_anglePoint1] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_anglePoint1(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_anglePoint1, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_anglePoint1, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_anglePoint2Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_anglePoint2] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_anglePoint2] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_anglePoint2] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_anglePoint2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_anglePoint2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_anglePoint2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_ShowNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_ShowName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_ShowName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_ShowName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_ShowName(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_ShowName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_ShowName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_ShowStereotypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_ShowStereotype] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_ShowStereotype] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_ShowStereotype] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_ShowStereotype(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_ShowStereotype, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_ShowStereotype, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_SourcePortFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_SourcePort] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_SourcePort] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_SourcePort] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_SourcePort(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_SourcePort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_SourcePort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_TargetPortFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_TargetPort] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_TargetPort] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_TargetPort] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_TargetPort(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_TargetPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_TargetPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_arrowFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_arrow] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_arrow] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_arrow] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_arrow(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_arrow, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_arrow, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_polygonFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_polygon] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_polygon] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_polygon] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_polygon(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_polygon, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_polygon, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdCGIImageDataFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIImageData] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIImageData] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "m_dataSize")) ~ 
      (scalaxb.ElemName(None, "m_data")) ~ 
      (scalaxb.ElemName(None, "m_srcFile")) ~ 
      (scalaxb.ElemName(None, "m_fileModifiedTime")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      rhapsody.lib.xsd.XsdCGIImageData(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_dataSize](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_data](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_srcFile](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_fileModifiedTime](p11, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIImageData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIImageData, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_dataSize](__obj.m_dataSize, None, Some("m_dataSize"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_data](__obj.m_data, None, Some("m_data"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_srcFile](__obj.m_srcFile, None, Some("m_srcFile"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_fileModifiedTime](__obj.m_fileModifiedTime, None, Some("m_fileModifiedTime"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIObjectInstanceFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIObjectInstance] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIObjectInstance] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_transform")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "m_AdditionalLabel")) ~ 
      (scalaxb.ElemName(None, "m_polygon")) ~ 
      (scalaxb.ElemName(None, "m_nNameFormat")) ~ 
      (scalaxb.ElemName(None, "m_nIsNameFormat")) ~ 
      (scalaxb.ElemName(None, "Attrs")) ~ 
      (scalaxb.ElemName(None, "Operations")) ~ 
      (scalaxb.ElemName(None, "m_multiplicity")) ~ 
      (scalaxb.ElemName(None, "AggregatesList")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 =>
      rhapsody.lib.xsd.XsdCGIObjectInstance(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](p12, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAttrs](p13, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdOperations](p14, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_multiplicity](p15, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](p16, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIObjectInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIObjectInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_transform](__obj.m_transform, None, Some("m_transform"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](__obj.m_AdditionalLabel, None, Some("m_AdditionalLabel"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_polygon](__obj.m_polygon, None, Some("m_polygon"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nNameFormat](__obj.m_nNameFormat, None, Some("m_nNameFormat"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](__obj.m_nIsNameFormat, None, Some("m_nIsNameFormat"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAttrs](__obj.Attrs, None, Some("Attrs"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdOperations](__obj.Operations, None, Some("Operations"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_multiplicity](__obj.m_multiplicity, None, Some("m_multiplicity"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAggregatesList](__obj.AggregatesList, None, Some("AggregatesList"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIClassFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIClass] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIClass] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      safeRep(((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_AdditionalLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_polygon")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nIsNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "frameset")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdFrameset](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Attrs")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAttrs](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Operations")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdOperations](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bFramesetModified")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bFramesetModified](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsMisplaced")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsMisplaced](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      rhapsody.lib.xsd.XsdCGIClass(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIClass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIClass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        __obj.xsdcgiclassoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIClassOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdAttrsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdAttrs] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdAttrs] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdAttrs(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdAttrs, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdAttrs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_conveyedFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_conveyed] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_conveyed] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_conveyed(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_conveyed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_conveyed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_itsTargetFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itsTarget] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_itsTarget] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_itsTarget] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_itsTarget(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_itsTarget, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_itsTarget, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowKeywordFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowKeyword] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowKeyword] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowKeyword] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowKeyword(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowKeyword, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowKeyword, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_itsSourceFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itsSource] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_itsSource] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_itsSource] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_itsSource(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_itsSource, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_itsSource, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_staticReactionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_staticReaction] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_staticReaction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_staticReaction] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_staticReaction(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_staticReaction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_staticReaction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdCGIStateFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIState] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIState] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_AdditionalLabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_AdditionalLabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_polygon")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_polygon](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nIsNameFormat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nIsNameFormat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "frameset")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdFrameset](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "nAndLineCount")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdNAndLineCount](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pInheritsFrom")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nInheritanceMask")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pDefaultComponentRelation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pDefaultComponentRelation](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_moveAndLineTimeStamp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "andLinePoly")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAndLinePoly](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pVirtualParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pVirtualParent](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIState(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIState, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIState, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgistateoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIStateOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGIStateChartFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIStateChart] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIStateChart] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "elementList")) ~ 
      (scalaxb.ElemName(None, "m_access")) ~ 
      (scalaxb.ElemName(None, "m_modified")) ~ 
      (scalaxb.ElemName(None, "m_nModifyDate")) ~ 
      (scalaxb.ElemName(None, "m_nCreateDate")) ~ 
      (scalaxb.ElemName(None, "m_bScaleWithZoom")) ~ 
      (scalaxb.ElemName(None, "m_arrowStyle")) ~ 
      (scalaxb.ElemName(None, "m_pRoot")) ~ 
      (scalaxb.ElemName(None, "m_currentLeftTop")) ~ 
      (scalaxb.ElemName(None, "m_currentRightBottom")) ~ 
      (scalaxb.ElemName(None, "m_bFreezeCompartmentContent")) ~ 
      (scalaxb.ElemName(None, "m_pInheritsFrom")) ~ 
      (scalaxb.ElemName(None, "AggregatesList")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 ~ p17 ~ p18 ~ p19 ~ p20 =>
      rhapsody.lib.xsd.XsdCGIStateChart(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdElementList](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_access](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_modified](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nModifyDate](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nCreateDate](p12, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bScaleWithZoom](p13, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_arrowStyle](p14, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pRoot](p15, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_currentLeftTop](p16, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_currentRightBottom](p17, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent](p18, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](p19, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](p20, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIStateChart, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIStateChart, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdElementList](__obj.elementList, None, Some("elementList"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_access](__obj.m_access, None, Some("m_access"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_modified](__obj.m_modified, None, Some("m_modified"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nModifyDate](__obj.m_nModifyDate, None, Some("m_nModifyDate"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nCreateDate](__obj.m_nCreateDate, None, Some("m_nCreateDate"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bScaleWithZoom](__obj.m_bScaleWithZoom, None, Some("m_bScaleWithZoom"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_arrowStyle](__obj.m_arrowStyle, None, Some("m_arrowStyle"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pRoot](__obj.m_pRoot, None, Some("m_pRoot"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_currentLeftTop](__obj.m_currentLeftTop, None, Some("m_currentLeftTop"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_currentRightBottom](__obj.m_currentRightBottom, None, Some("m_currentRightBottom"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent](__obj.m_bFreezeCompartmentContent, None, Some("m_bFreezeCompartmentContent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](__obj.m_pInheritsFrom, None, Some("m_pInheritsFrom"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAggregatesList](__obj.AggregatesList, None, Some("AggregatesList"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIClassChartFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIClassChart] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIClassChart] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "elementList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdElementList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_access")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_access](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_modified")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_modified](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nModifyDate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nModifyDate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_nCreateDate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nCreateDate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bScaleWithZoom")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bScaleWithZoom](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_arrowStyle")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_arrowStyle](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pRoot")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pRoot](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_currentLeftTop")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_currentLeftTop](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_currentRightBottom")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_currentRightBottom](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bFreezeCompartmentContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bFreezeCompartmentContent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_rmmServerID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_rmmServerID](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIClassChart(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIClassChart, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIClassChart, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiclasschartoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIClassChartOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGIImageFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIImage] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIImage] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_transform")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pImageViewData")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pImageViewData](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_points")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_points](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIImage(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIImage, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIImage, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiimageoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIImageOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGIInheritanceFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIInheritance] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIInheritance] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pSource")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pSource](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pTarget")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pTarget](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_rpn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_rpn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_arrow](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint1")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint1](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_line_style")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_line_style](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_SourcePort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SourcePort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_TargetPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_TargetPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_ShowName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_ShowName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_ShowStereotype")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_ShowStereotype](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIInheritance(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIInheritance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIInheritance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiinheritanceoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIInheritanceOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdCGITransFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGITrans] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGITrans] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "m_pSource")) ~ 
      (scalaxb.ElemName(None, "m_sourceType")) ~ 
      (scalaxb.ElemName(None, "m_pTarget")) ~ 
      (scalaxb.ElemName(None, "m_targetType")) ~ 
      (scalaxb.ElemName(None, "m_direction")) ~ 
      (scalaxb.ElemName(None, "m_rpn")) ~ 
      (scalaxb.ElemName(None, "m_anglePoint1")) ~ 
      (scalaxb.ElemName(None, "m_anglePoint2")) ~ 
      (scalaxb.ElemName(None, "m_line_style")) ~ 
      (scalaxb.ElemName(None, "m_SourcePort")) ~ 
      (scalaxb.ElemName(None, "m_TargetPort")) ~ 
      (scalaxb.ElemName(None, "m_pInheritsFrom")) ~ 
      (scalaxb.ElemName(None, "m_nInheritanceMask")) ~ 
      (scalaxb.ElemName(None, "m_bShowName")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 ~ p17 ~ p18 ~ p19 ~ p20 ~ p21 =>
      rhapsody.lib.xsd.XsdCGITrans(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pSource](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceType](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pTarget](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetType](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_direction](p12, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_rpn](p13, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint1](p14, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint2](p15, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_line_style](p16, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SourcePort](p17, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_TargetPort](p18, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](p19, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](p20, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowName](p21, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGITrans, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGITrans, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pSource](__obj.m_pSource, None, Some("m_pSource"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_sourceType](__obj.m_sourceType, None, Some("m_sourceType"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pTarget](__obj.m_pTarget, None, Some("m_pTarget"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_targetType](__obj.m_targetType, None, Some("m_targetType"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_direction](__obj.m_direction, None, Some("m_direction"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_rpn](__obj.m_rpn, None, Some("m_rpn"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_anglePoint1](__obj.m_anglePoint1, None, Some("m_anglePoint1"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_anglePoint2](__obj.m_anglePoint2, None, Some("m_anglePoint2"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_line_style](__obj.m_line_style, None, Some("m_line_style"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_SourcePort](__obj.m_SourcePort, None, Some("m_SourcePort"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_TargetPort](__obj.m_TargetPort, None, Some("m_TargetPort"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](__obj.m_pInheritsFrom, None, Some("m_pInheritsFrom"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](__obj.m_nInheritanceMask, None, Some("m_nInheritanceMask"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bShowName](__obj.m_bShowName, None, Some("m_bShowName"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIInformationFlowFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIInformationFlow] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIInformationFlow] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pSource")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pSource](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pTarget")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pTarget](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_rpn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_rpn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint1")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint1](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_line_style")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_line_style](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_SourcePort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SourcePort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_TargetPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_TargetPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowKeyword")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowKeyword](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_showConveyed")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_showConveyed](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_keyword")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_keyword](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_conveyed")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_conveyed](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_flow_direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_flow_direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_arrow](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIInformationFlow(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIInformationFlow, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIInformationFlow, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiinformationflowoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIInformationFlowOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdITransitionFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdITransition] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdITransition] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_myState")) ~ 
      (scalaxb.ElemName(None, "_name")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_itsTarget")) ~ 
      (scalaxb.ElemName(None, "_staticReaction")) ~ 
      (scalaxb.ElemName(None, "_itsSource")) ~ 
      (scalaxb.ElemName(None, "AggregatesList")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      rhapsody.lib.xsd.XsdITransition(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsTarget](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_staticReaction](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsSource](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](p9, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdITransition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdITransition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_myState](__obj._myState, None, Some("_myState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_itsTarget](__obj._itsTarget, None, Some("_itsTarget"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_staticReaction](__obj._staticReaction, None, Some("_staticReaction"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_itsSource](__obj._itsSource, None, Some("_itsSource"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAggregatesList](__obj.AggregatesList, None, Some("AggregatesList"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdILabelFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdILabel] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdILabel] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_itsTrigger")) ~ 
      (scalaxb.ElemName(None, "_itsGuard")) ~ 
      (scalaxb.ElemName(None, "_itsAction")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      rhapsody.lib.xsd.XsdILabel(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p6, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdILabel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdILabel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[String](__obj._itsTrigger, None, Some("_itsTrigger"), __scope, false),
        scalaxb.toXML[String](__obj._itsGuard, None, Some("_itsGuard"), __scope, false),
        scalaxb.toXML[String](__obj._itsAction, None, Some("_itsAction"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdRHAPSODYu45MODELFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL] =
      phrase(safeRep(((scalaxb.ElemName(None, "IClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IAssociationEnd")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIAssociationEnd](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IAttribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIAttribute](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IDependency")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIDependency](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IGeneralization")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIGeneralization](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IInformationFlow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIInformationFlow](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ILiteralSpecification")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdILiteralSpecification](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IPart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIPart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ISysMLPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdISysMLPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ITag")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdITag](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IMHyperLink")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIMHyperLink](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IDiagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIDiagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IComment")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIComment](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IStateChart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIStateChart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IStateChartDiagram")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIStateChartDiagram](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ITransition")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdITransition](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ILabel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdILabel](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IFork")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIFork](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IDefaultDrvdTrans")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIDefaultDrvdTrans](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IConstraint")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIConstraint](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IAnchor")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIAnchor](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IInformationItem")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIInformationItem](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IMSC")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIMSC](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIClassChart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIClassChart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIDiagramFrame")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIDiagramFrame](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIImageData")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIImageData](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIImage")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIImage](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGICompartment")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGICompartment](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIPortConnector")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIPortConnector](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIAnnotation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIAnnotation](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIInheritance")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIInheritance](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIInformationFlow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIInformationFlow](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIGenericElement")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIGenericElement](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIStateChart")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIStateChart](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGITrans")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGITrans](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIObjectInstance")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIObjectInstance](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIConnector")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIConnector](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "CGIAssociationEnd")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIAssociationEnd](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IInstanceValue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIInstanceValue](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "IType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIType](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdRHAPSODYu45MODEL(p1) })
    
    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdRHAPSODYu45MODEL, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdrhapsodyu45modeloption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdRHAPSODYu45MODELOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdRhapsodyArchiveFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdRhapsodyArchive] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdRhapsodyArchive] =
      phrase((scalaxb.ElemName(None, "MagicNumber")) ~ 
      (scalaxb.ElemName(None, "CODE-PAGE")) ~ 
      (scalaxb.ElemName(None, "version")) ~ 
      (scalaxb.ElemName(None, "lang")) ~ 
      (scalaxb.ElemName(None, "BuildNo")) ~ 
      opt(scalaxb.ElemName(None, "RMMMinimumClientVersion")) ~ 
      (scalaxb.ElemName(None, "RHAPSODY-MODEL")) ~ 
      (scalaxb.ElemName(None, "OslcLinks")) ~ 
      (scalaxb.ElemName(None, "INCLUDES-RHAPSODY-INDEX")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      rhapsody.lib.xsd.XsdRhapsodyArchive(scalaxb.fromXML[rhapsody.lib.xsd.XsdMagicNumber](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Short](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Long](p5, scalaxb.ElemName(node) :: stack),
        p6.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdOslcLinks](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Boolean](p9, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdRhapsodyArchive, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.XsdMagicNumber](__obj.MagicNumber, None, Some("MagicNumber"), __scope, false),
        scalaxb.toXML[Short](__obj.CODEu45PAGE, None, Some("CODE-PAGE"), __scope, false),
        scalaxb.toXML[String](__obj.version, None, Some("version"), __scope, false),
        scalaxb.toXML[String](__obj.lang, None, Some("lang"), __scope, false),
        scalaxb.toXML[Long](__obj.BuildNo, None, Some("BuildNo"), __scope, false),
        __obj.RMMMinimumClientVersion map { scalaxb.toXML[BigDecimal](_, None, Some("RMMMinimumClientVersion"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[rhapsody.lib.xsd.XsdRHAPSODYu45MODEL](__obj.RHAPSODYu45MODEL, None, Some("RHAPSODY-MODEL"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdOslcLinks](__obj.OslcLinks, None, Some("OslcLinks"), __scope, false),
        scalaxb.toXML[Boolean](__obj.INCLUDESu45RHAPSODYu45INDEX, None, Some("INCLUDES-RHAPSODY-INDEX"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIStateFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIState] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIState] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_description](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_parent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_parent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_defaultTrans")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_defaultTrans](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_stateType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_stateType](x, scalaxb.ElemName(node) :: stack)))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIState(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIState, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIState, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdistateoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIStateOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdStereotypesFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdStereotypes] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdStereotypes] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdStereotypes(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdStereotypes, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdStereotypes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_baseFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_base] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_base] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_base(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_base, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_base, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_classModifierFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_classModifier] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_classModifier] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_classModifier] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_classModifier(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_classModifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_classModifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_dependentFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_dependent] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_dependent] =
      phrase((scalaxb.ElemName(None, "INObjectHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_dependent(scalaxb.fromXML[rhapsody.lib.xsd.XsdINObjectHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_dependent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_dependent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdINObjectHandle](__obj.INObjectHandle, None, Some("INObjectHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_dependsOnFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_dependsOn] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_dependsOn] =
      phrase((scalaxb.ElemName(None, "INObjectHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_dependsOn(scalaxb.fromXML[rhapsody.lib.xsd.XsdINObjectHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_dependsOn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_dependsOn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdINObjectHandle](__obj.INObjectHandle, None, Some("INObjectHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_directionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_direction] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_direction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_direction] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_direction(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_displayNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_displayName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_displayName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_displayName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_displayName(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_displayName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_displayName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hclassFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hclass] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hclass] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hclass] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hclass(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hclass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hclass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hfilenameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hfilename] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hfilename] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hfilename] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hfilename(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hfilename, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hfilename, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hidFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hid] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hid] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hid] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hid(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hid, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hid, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hm2ClassFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hm2Class] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hm2Class] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hm2Class] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hm2Class(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hm2Class, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hm2Class, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hnameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hname] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hname] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hname] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hname(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hname, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hname, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_hsubsystemFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_hsubsystem] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_hsubsystem] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_hsubsystem] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_hsubsystem(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_hsubsystem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_hsubsystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_idFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_id] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_id] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_id(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_implicitClassFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_implicitClass] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_implicitClass] =
      phrase(safeRep(((scalaxb.ElemName(None, "IClass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIClass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ISysMLPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdISysMLPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ITag")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdITag](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ILiteralSpecification")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdILiteralSpecification](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_implicitClass(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_implicitClass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_implicitClass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsd_implicitclassoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.Xsd_implicitClassOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_inheritanceTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_inheritanceType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_inheritanceType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_inheritanceType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_inheritanceType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_inheritanceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_inheritanceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_inverseFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_inverse] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_inverse] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_inverse(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_inverse, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_inverse, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_isConstantFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isConstant] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_isConstant] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_isConstant] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_isConstant(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_isConstant, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_isConstant, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_isOrderedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isOrdered] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_isOrdered] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_isOrdered] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_isOrdered(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_isOrdered, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_isOrdered, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_isReferenceAttrFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isReferenceAttr] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_isReferenceAttr] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_isReferenceAttr] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_isReferenceAttr(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_isReferenceAttr, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_isReferenceAttr, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_isVirtualFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_isVirtual] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_isVirtual] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_isVirtual] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_isVirtual(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_isVirtual, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_isVirtual, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_itsStateChartFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_itsStateChart] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_itsStateChart] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_itsStateChart(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_itsStateChart, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_itsStateChart, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_lastIDFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_lastID] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_lastID] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_lastID] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_lastID(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_lastID, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_lastID, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_linkTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_linkType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_linkType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_linkType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_linkType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_linkType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_linkType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_modifiedTimeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_modifiedTime] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_modifiedTime] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_modifiedTime] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_modifiedTime(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_modifiedTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_modifiedTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_modifiedTimeWeakFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_modifiedTimeWeak] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_modifiedTimeWeak] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_modifiedTimeWeak] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_modifiedTimeWeak(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_modifiedTimeWeak, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_modifiedTimeWeak, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_multiplicityFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_multiplicity] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_multiplicity] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_multiplicity] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_multiplicity(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_multiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_multiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_myStateFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_myState] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_myState] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_myState] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_myState(scalaxb.fromXML[Short](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_myState, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_myState, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_name2Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_name2] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_name2] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_name2] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_name2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_name2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_name2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_navigabilityFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_navigability] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_navigability] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_navigability] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_navigability(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_navigability, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_navigability, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_otherClassFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_otherClass] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_otherClass] =
      phrase((scalaxb.ElemName(None, "IClassifierHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_otherClass(scalaxb.fromXML[rhapsody.lib.xsd.XsdIClassifierHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_otherClass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_otherClass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIClassifierHandle](__obj.IClassifierHandle, None, Some("IClassifierHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_protectionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_protection] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_protection] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_protection] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_protection(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_protection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_protection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_staticFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_static] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_static] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_static] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_static(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_static, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_static, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_theMainDiagramFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_theMainDiagram] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_theMainDiagram] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_theMainDiagram(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_theMainDiagram, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_theMainDiagram, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_typeOfFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_typeOf] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_typeOf] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_typeOf(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_typeOf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_typeOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_value2Format extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_value2] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_value2] =
      phrase(optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "IHandle")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      rhapsody.lib.xsd.Xsd_value2(Seq.concat(p1.toList,
        p2.toList,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_value2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_value2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultRhapsodylibxsd_XsdDirectionu93Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdDirectionu93] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdDirectionu93] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdDirectionu93] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdDirectionu93(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdDirectionu93, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdDirectionu93, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdEnd1u93Format extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdEnd1u93] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdEnd1u93] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdEnd1u93(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdEnd1u93, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdEnd1u93, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdEnd2u93Format extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdEnd2u93] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdEnd2u93] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdEnd2u93(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdEnd2u93, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdEnd2u93, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdFileNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdFileName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdFileName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdFileName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdFileName(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdFileName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdFileName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdStrongCGTimeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdStrongCGTime] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdStrongCGTime] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdStrongCGTime] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdStrongCGTime(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdStrongCGTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdStrongCGTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdWeakCGTimeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdWeakCGTime] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdWeakCGTime] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdWeakCGTime] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdWeakCGTime(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdWeakCGTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdWeakCGTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_dataFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_data] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_data] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_data] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_data(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_data, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_data, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_dataSizeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_dataSize] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_dataSize] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_dataSize] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_dataSize(scalaxb.fromXML[Int](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_dataSize, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_dataSize, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_directionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_direction] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_direction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_direction] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_direction(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_fileModifiedTimeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_fileModifiedTime] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_fileModifiedTime] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_fileModifiedTime] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_fileModifiedTime(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_fileModifiedTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_fileModifiedTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_flow_directionFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_flow_direction] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_flow_direction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_flow_direction] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_flow_direction(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_flow_direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_flow_direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_keywordFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_keyword] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_keyword] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_keyword(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_keyword, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_keyword, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_line_styleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_line_style] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_line_style] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_line_style] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_line_style(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_line_style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_line_style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nHorizontalSpacingFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nHorizontalSpacing] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nHorizontalSpacing] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nHorizontalSpacing] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nHorizontalSpacing(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nHorizontalSpacing, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nHorizontalSpacing, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nInheritanceMaskFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nInheritanceMask] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nInheritanceMask] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nInheritanceMask] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nInheritanceMask(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nInheritanceMask, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nInheritanceMask, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_nVerticalSpacingFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_nVerticalSpacing] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_nVerticalSpacing] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_nVerticalSpacing] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_nVerticalSpacing(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_nVerticalSpacing, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_nVerticalSpacing, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pImageViewDataFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pImageViewData] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pImageViewData] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pImageViewData(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pImageViewData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pImageViewData, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_pInheritsFromFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pInheritsFrom] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pInheritsFrom] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pInheritsFrom(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pInheritsFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pInheritsFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_pSourceFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pSource] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pSource] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pSource] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pSource(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pSource, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pSource, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pTargetFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pTarget] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pTarget] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pTarget] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pTarget(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pTarget, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pTarget, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pointsFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_points] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_points] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_points] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_points(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_points, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_points, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_providedInterfaceLabelFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_providedInterfaceLabel] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_providedInterfaceLabel] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_providedInterfaceLabel(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_providedInterfaceLabel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_providedInterfaceLabel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_requiredInterfaceLabelFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_requiredInterfaceLabel] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_requiredInterfaceLabel] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_requiredInterfaceLabel(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_requiredInterfaceLabel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_requiredInterfaceLabel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_rpnFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_rpn] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_rpn] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_rpn(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_rpn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_rpn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_showConveyedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_showConveyed] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_showConveyed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_showConveyed] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_showConveyed(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_showConveyed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_showConveyed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_sourceTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_sourceType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_sourceType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_sourceType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_sourceType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_sourceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_sourceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_srcFileFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_srcFile] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_srcFile] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_srcFile] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_srcFile(scalaxb.fromXML[java.net.URI](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_srcFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_srcFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_targetTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_targetType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_targetType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_targetType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_targetType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_targetType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_targetType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bOrderedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bOrdered] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bOrdered] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bOrdered] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bOrdered(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bOrdered, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bOrdered, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowInheritedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowInherited] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowInherited] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowInherited] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowInherited(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowInherited, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowInherited, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_itemValueOfFontPropertiesMapCountFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_itemValueOfFontPropertiesMapCount, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_fontPropValuesFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_fontPropValues] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_fontPropValues] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_fontPropValues] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_fontPropValues(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_fontPropValues, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_fontPropValues, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_parentFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_parent] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_parent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_parent] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_parent(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_parent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_parent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_defaultTransFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_defaultTrans] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_defaultTrans] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_defaultTrans] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_defaultTrans(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_defaultTrans, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_defaultTrans, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdHyperlinksFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdHyperlinks] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdHyperlinks] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdHyperlinks(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdHyperlinks, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdHyperlinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIInternalHyperlinkFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIInternalHyperlink] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIInternalHyperlink] =
      phrase((scalaxb.ElemName(None, "_name")) ~ 
      (scalaxb.ElemName(None, "_textType")) ~ 
      (scalaxb.ElemName(None, "_target")) ^^
      { case p1 ~ p2 ~ p3 =>
      rhapsody.lib.xsd.XsdIInternalHyperlink(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_textType](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_target](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIInternalHyperlink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIInternalHyperlink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_textType](__obj._textType, None, Some("_textType"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_target](__obj._target, None, Some("_target"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_targetFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.Xsd_target] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.Xsd_target] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.Xsd_target(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_target, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_target, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_textTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_textType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_textType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_textType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_textType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_textType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_textType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdNAndLineCountFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdNAndLineCount] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdNAndLineCount] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdNAndLineCount] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdNAndLineCount(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdNAndLineCount, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdNAndLineCount, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pDefaultComponentRelationFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pDefaultComponentRelation] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pDefaultComponentRelation] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pDefaultComponentRelation] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pDefaultComponentRelation(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pDefaultComponentRelation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pDefaultComponentRelation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowName(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_multiplicityFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_multiplicity] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_multiplicity] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_multiplicity(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_multiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_multiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_csContextFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_csContext] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_csContext] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_csContext] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_csContext(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_csContext, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_csContext, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bIsStructuredFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsStructured] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bIsStructured] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bIsStructured] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bIsStructured(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bIsStructured, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bIsStructured, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_csPartsArrayFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_csPartsArray] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_csPartsArray] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_csPartsArray] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_csPartsArray(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_csPartsArray, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_csPartsArray, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdPortsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdPorts] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdPorts] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdPorts(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdPorts, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdPorts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIConstraintFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIConstraint] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIConstraint] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_body")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_body](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_displayName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_displayName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_lastID")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_lastID](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "AggregatesList")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIConstraint(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIConstraint, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiconstraintoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIConstraintOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_bodyFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_body] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_body] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_body] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_body(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_body, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_body, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIDefaultDrvdTransFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIDefaultDrvdTrans] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIDefaultDrvdTrans] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_myState")) ~ 
      (scalaxb.ElemName(None, "_name")) ~ 
      (scalaxb.ElemName(None, "Stereotypes")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_errorStatus")) ~ 
      (scalaxb.ElemName(None, "_itsTarget")) ~ 
      (scalaxb.ElemName(None, "_staticReaction")) ~ 
      (scalaxb.ElemName(None, "_itsSource")) ~ 
      (scalaxb.ElemName(None, "_ofState")) ~ 
      (scalaxb.ElemName(None, "AggregatesList")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      rhapsody.lib.xsd.XsdIDefaultDrvdTrans(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_errorStatus](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsTarget](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_staticReaction](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_itsSource](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_ofState](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdAggregatesList](p12, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIDefaultDrvdTrans, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIDefaultDrvdTrans, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_myState](__obj._myState, None, Some("_myState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdStereotypes](__obj.Stereotypes, None, Some("Stereotypes"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_errorStatus](__obj._errorStatus, None, Some("_errorStatus"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_itsTarget](__obj._itsTarget, None, Some("_itsTarget"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_staticReaction](__obj._staticReaction, None, Some("_staticReaction"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_itsSource](__obj._itsSource, None, Some("_itsSource"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_ofState](__obj._ofState, None, Some("_ofState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdAggregatesList](__obj.AggregatesList, None, Some("AggregatesList"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_errorStatusFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_errorStatus] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_errorStatus] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_errorStatus] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_errorStatus(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_errorStatus, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_errorStatus, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_ofStateFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_ofState] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_ofState] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_ofState] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_ofState(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_ofState, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_ofState, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIForkFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIFork] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIFork] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_myState")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "Stereotypes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdStereotypes](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTimeWeak")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_modifiedTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_parent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_parent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_connectorType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_connectorType](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdIFork(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIFork, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIFork, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdiforkoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdIForkOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_Xsd_connectorTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_connectorType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_connectorType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_connectorType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_connectorType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_connectorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_connectorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdCGIConnectorFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIConnector] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIConnector] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "m_type")) ~ 
      (scalaxb.ElemName(None, "m_pModelObject")) ~ 
      (scalaxb.ElemName(None, "m_pParent")) ~ 
      (scalaxb.ElemName(None, "m_name")) ~ 
      (scalaxb.ElemName(None, "m_drawBehavior")) ~ 
      (scalaxb.ElemName(None, "m_transform")) ~ 
      (scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ~ 
      (scalaxb.ElemName(None, "m_position")) ~ 
      (scalaxb.ElemName(None, "m_pInheritsFrom")) ~ 
      (scalaxb.ElemName(None, "m_nInheritanceMask")) ~ 
      (scalaxb.ElemName(None, "m_SubType")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      rhapsody.lib.xsd.XsdCGIConnector(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_transform](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_position](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](p10, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](p11, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SubType](p12, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIConnector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIConnector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_type](__obj.m_type, None, Some("m_type"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pModelObject](__obj.m_pModelObject, None, Some("m_pModelObject"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pParent](__obj.m_pParent, None, Some("m_pParent"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_name](__obj.m_name, None, Some("m_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_drawBehavior](__obj.m_drawBehavior, None, Some("m_drawBehavior"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_transform](__obj.m_transform, None, Some("m_transform"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](__obj.m_bIsPreferencesInitialized, None, Some("m_bIsPreferencesInitialized"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_position](__obj.m_position, None, Some("m_position"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_pInheritsFrom](__obj.m_pInheritsFrom, None, Some("m_pInheritsFrom"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_nInheritanceMask](__obj.m_nInheritanceMask, None, Some("m_nInheritanceMask"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.XsdM_SubType](__obj.m_SubType, None, Some("m_SubType"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdTagsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdTags] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdTags] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdTags(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdTags, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdTags, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_bVisibleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bVisible] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bVisible] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bVisible] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bVisible(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bVisible, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bVisible, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIObjectLinkHandleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdIObjectLinkHandle] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdIObjectLinkHandle] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdIObjectLinkHandle] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdIObjectLinkHandle(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIObjectLinkHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIObjectLinkHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pInstanceFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pInstance] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pInstance] =
      phrase((scalaxb.ElemName(None, "IObjectLinkHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pInstance(scalaxb.fromXML[rhapsody.lib.xsd.XsdIObjectLinkHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIObjectLinkHandle](__obj.IObjectLinkHandle, None, Some("IObjectLinkHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_pInverseInstanceFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pInverseInstance] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pInverseInstance] =
      phrase((scalaxb.ElemName(None, "IObjectLinkHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pInverseInstance(scalaxb.fromXML[rhapsody.lib.xsd.XsdIObjectLinkHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pInverseInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pInverseInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIObjectLinkHandle](__obj.IObjectLinkHandle, None, Some("IObjectLinkHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIAssociationEndHandleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIAssociationEndHandle] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIAssociationEndHandle] =
      phrase((scalaxb.ElemName(None, "_hm2Class")) ~ 
      (scalaxb.ElemName(None, "_hfilename")) ~ 
      (scalaxb.ElemName(None, "_hsubsystem")) ~ 
      (scalaxb.ElemName(None, "_hclass")) ~ 
      (scalaxb.ElemName(None, "_hname")) ~ 
      (scalaxb.ElemName(None, "_hid")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      rhapsody.lib.xsd.XsdIAssociationEndHandle(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hm2Class](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hfilename](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hsubsystem](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hclass](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hname](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_hid](p6, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIAssociationEndHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIAssociationEndHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_hm2Class](__obj._hm2Class, None, Some("_hm2Class"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hfilename](__obj._hfilename, None, Some("_hfilename"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hsubsystem](__obj._hsubsystem, None, Some("_hsubsystem"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hclass](__obj._hclass, None, Some("_hclass"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hname](__obj._hname, None, Some("_hname"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_hid](__obj._hid, None, Some("_hid"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_pInverseModelObjectFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_pInverseModelObject] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_pInverseModelObject] =
      phrase((scalaxb.ElemName(None, "IAssociationEndHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_pInverseModelObject(scalaxb.fromXML[rhapsody.lib.xsd.XsdIAssociationEndHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pInverseModelObject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pInverseModelObject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIAssociationEndHandle](__obj.IAssociationEndHandle, None, Some("IAssociationEndHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_bShowSourceMultiplicityFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowSourceRoleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSourceRole] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowSourceRole] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowSourceRole] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowSourceRole(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowSourceRole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowSourceRole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowSpecificTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowSpecificType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowSpecificType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowSpecificType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowSpecificType(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowSpecificType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowSpecificType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowTargetMultiplicityFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowTargetRoleFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowTargetRole] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowTargetRole] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowTargetRole] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowTargetRole(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowTargetRole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowTargetRole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowLinkNameFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowLinkName] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowLinkName] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowLinkName] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowLinkName(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowLinkName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowLinkName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowQualifier1Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowQualifier1] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowQualifier1] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowQualifier1] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowQualifier1(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowQualifier1, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowQualifier1, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bShowQualifier2Format extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bShowQualifier2] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bShowQualifier2] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bShowQualifier2] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bShowQualifier2(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bShowQualifier2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bShowQualifier2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_bInstanceFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bInstance] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bInstance] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bInstance] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bInstance(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_sourceMultiplicityFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_sourceMultiplicity] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_sourceMultiplicity] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_sourceMultiplicity(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_sourceMultiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_sourceMultiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_sourceQualifierFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_sourceQualifier] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_sourceQualifier] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_sourceQualifier(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_sourceQualifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_sourceQualifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_sourceRoleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_sourceRole] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_sourceRole] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_sourceRole(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_sourceRole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_sourceRole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_specificTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_specificType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_specificType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_specificType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_specificType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_specificType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_specificType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_targetMultiplicityFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_targetMultiplicity] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_targetMultiplicity] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_targetMultiplicity(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_targetMultiplicity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_targetMultiplicity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_targetQualifierFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_targetQualifier] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_targetQualifier] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_targetQualifier(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_targetQualifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_targetQualifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_targetRoleFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdM_targetRole] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdM_targetRole] =
      phrase((scalaxb.ElemName(None, "CGIText")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdM_targetRole(scalaxb.fromXML[rhapsody.lib.xsd.XsdCGIText](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_targetRole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_targetRole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdCGIText](__obj.CGIText, None, Some("CGIText"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdCGIAssociationEndFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdCGIAssociationEnd] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdCGIAssociationEnd] =
      phrase(safeRep(((scalaxb.ElemName(None, "_id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_type](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pParent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pParent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_name")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_name](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_drawBehavior")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_drawBehavior](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bIsPreferencesInitialized")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bIsPreferencesInitialized](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pSource")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pSource](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pTarget")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pTarget](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_rpn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_rpn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint1")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint1](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_anglePoint2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_anglePoint2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_line_style")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_line_style](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_SourcePort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_SourcePort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_TargetPort")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_TargetPort](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pInverseModelObject")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInverseModelObject](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pInstance")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInstance](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_pInverseInstance")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_pInverseInstance](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowSourceMultiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowSourceMultiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowSourceRole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowSourceRole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowTargetMultiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowTargetMultiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowTargetRole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowTargetRole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowLinkName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowLinkName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowSpecificType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowSpecificType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bInstance")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bInstance](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowQualifier1")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowQualifier1](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_bShowQualifier2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_bShowQualifier2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceRole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceRole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetRole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetRole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceMultiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceMultiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetMultiplicity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetMultiplicity](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_sourceQualifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_sourceQualifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_targetQualifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_targetQualifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_specificType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_specificType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "_properties")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.Xsd_properties](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "m_arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rhapsody.lib.xsd.XsdM_arrow](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdCGIAssociationEnd(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdCGIAssociationEnd, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdCGIAssociationEnd, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xsdcgiassociationendoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[rhapsody.lib.xsd.XsdCGIAssociationEndOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultRhapsodylibxsd_XsdM_bIsMisplacedFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_bIsMisplaced] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_bIsMisplaced] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_bIsMisplaced] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_bIsMisplaced(scalaxb.fromXML[Byte](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_bIsMisplaced, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_bIsMisplaced, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIAnchorFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIAnchor] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIAnchor] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_myState")) ~ 
      (scalaxb.ElemName(None, "_name")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_dependsOn")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      rhapsody.lib.xsd.XsdIAnchor(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_dependsOn](p6, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIAnchor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIAnchor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_myState](__obj._myState, None, Some("_myState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_dependsOn](__obj._dependsOn, None, Some("_dependsOn"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdM_moveAndLineTimeStampFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_moveAndLineTimeStamp, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdIInformationItemFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIInformationItem] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIInformationItem] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_myState")) ~ 
      (scalaxb.ElemName(None, "_name")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      rhapsody.lib.xsd.XsdIInformationItem(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_name2](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIInformationItem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIInformationItem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_myState](__obj._myState, None, Some("_myState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_name2](__obj._name, None, Some("_name"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_stateTypeFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_stateType] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_stateType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_stateType] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_stateType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_stateType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_stateType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdAndLinePolyFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdAndLinePoly] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdAndLinePoly] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdAndLinePoly] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdAndLinePoly(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdAndLinePoly, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdAndLinePoly, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdM_pVirtualParentFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.XsdM_pVirtualParent] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.XsdM_pVirtualParent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.XsdM_pVirtualParent] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.XsdM_pVirtualParent(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdM_pVirtualParent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdM_pVirtualParent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_XsdTransitionsFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdTransitions] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdTransitions] =
      phrase((scalaxb.ElemName(None, "IRPYRawContainer")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdTransitions(scalaxb.fromXML[rhapsody.lib.xsd.XsdIRPYRawContainer](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdTransitions, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdTransitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIRPYRawContainer](__obj.IRPYRawContainer, None, Some("IRPYRawContainer"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdEnd1ObjectPortu93Format extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdEnd1ObjectPortu93] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdEnd1ObjectPortu93] =
      phrase((scalaxb.ElemName(None, "IHandle")) ^^
      { case p1 =>
      rhapsody.lib.xsd.XsdEnd1ObjectPortu93(scalaxb.fromXML[rhapsody.lib.xsd.XsdIHandle](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdEnd1ObjectPortu93, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdEnd1ObjectPortu93, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[rhapsody.lib.xsd.XsdIHandle](__obj.IHandle, None, Some("IHandle"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdIInstanceValueFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIInstanceValue] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIInstanceValue] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_value")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      rhapsody.lib.xsd.XsdIInstanceValue(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_value2](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIInstanceValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIInstanceValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_value2](__obj._value, None, Some("_value"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_XsdITypeFormat extends scalaxb.ElemNameParser[rhapsody.lib.xsd.XsdIType] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rhapsody.lib.xsd.XsdIType] =
      phrase((scalaxb.ElemName(None, "_id")) ~ 
      (scalaxb.ElemName(None, "_myState")) ~ 
      (scalaxb.ElemName(None, "_modifiedTimeWeak")) ~ 
      (scalaxb.ElemName(None, "_modifiedTime")) ~ 
      (scalaxb.ElemName(None, "_declaration")) ~ 
      (scalaxb.ElemName(None, "_kind")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      rhapsody.lib.xsd.XsdIType(scalaxb.fromXML[rhapsody.lib.xsd.Xsd_id](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_myState](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_modifiedTime](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_declaration](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[rhapsody.lib.xsd.Xsd_kind](p6, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.XsdIType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.XsdIType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rhapsody.lib.xsd.Xsd_id](__obj._id, None, Some("_id"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_myState](__obj._myState, None, Some("_myState"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTimeWeak](__obj._modifiedTimeWeak, None, Some("_modifiedTimeWeak"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_modifiedTime](__obj._modifiedTime, None, Some("_modifiedTime"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_declaration](__obj._declaration, None, Some("_declaration"), __scope, false),
        scalaxb.toXML[rhapsody.lib.xsd.Xsd_kind](__obj._kind, None, Some("_kind"), __scope, false))

  }

  trait DefaultRhapsodylibxsd_Xsd_declarationFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_declaration] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_declaration] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_declaration] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_declaration(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_declaration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_declaration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultRhapsodylibxsd_Xsd_kindFormat extends scalaxb.XMLFormat[rhapsody.lib.xsd.Xsd_kind] with scalaxb.CanWriteChildNodes[rhapsody.lib.xsd.Xsd_kind] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rhapsody.lib.xsd.Xsd_kind] = seq match {
      case node: scala.xml.Node => Right(rhapsody.lib.xsd.Xsd_kind(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: rhapsody.lib.xsd.Xsd_kind, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rhapsody.lib.xsd.Xsd_kind, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }


}

